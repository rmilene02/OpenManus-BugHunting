"""
Vulnerability Correlation and Knowledge Graph Engine

This module implements advanced vulnerability correlation techniques that connect
the dots between different findings to discover complex attack chains and
high-impact vulnerabilities.

Features:
- Knowledge graph construction of target assets and vulnerabilities
- Vulnerability chaining and correlation logic
- Attack path analysis and exploitation chain discovery
- Risk amplification through vulnerability combinations
- AI-powered correlation analysis
"""

import asyncio
import json
import networkx as nx
import re
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass
from enum import Enum
from app.logger import logger


class VulnerabilityType(Enum):
    """Enumeration of vulnerability types"""
    INFORMATION_DISCLOSURE = "information_disclosure"
    INJECTION = "injection"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_BYPASS = "authorization_bypass"
    FILE_UPLOAD = "file_upload"
    CONFIGURATION_ERROR = "configuration_error"
    BUSINESS_LOGIC = "business_logic"
    CRYPTOGRAPHIC = "cryptographic"
    NETWORK = "network"
    UNKNOWN = "unknown"


class RiskLevel(Enum):
    """Risk level enumeration"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Asset:
    """Represents a target asset"""
    id: str
    type: str  # domain, subdomain, ip, url, endpoint, service
    value: str
    properties: Dict[str, Any]
    technologies: List[str]
    services: List[Dict[str, Any]]


@dataclass
class Vulnerability:
    """Represents a discovered vulnerability"""
    id: str
    type: VulnerabilityType
    asset_id: str
    title: str
    description: str
    risk_level: RiskLevel
    cvss_score: float
    evidence: Dict[str, Any]
    exploitation_complexity: str
    prerequisites: List[str]
    impact: Dict[str, Any]


@dataclass
class AttackPath:
    """Represents an attack path through multiple vulnerabilities"""
    id: str
    vulnerabilities: List[str]  # Vulnerability IDs
    description: str
    total_risk_score: float
    feasibility: str
    business_impact: str
    steps: List[Dict[str, Any]]


class VulnerabilityCorrelator:
    """Advanced vulnerability correlation and analysis engine"""
    
    def __init__(self, llm_client=None):
        self.llm_client = llm_client
        
        # Knowledge graph
        self.knowledge_graph = nx.DiGraph()
        
        # Data storage
        self.assets = {}  # asset_id -> Asset
        self.vulnerabilities = {}  # vuln_id -> Vulnerability
        self.attack_paths = {}  # path_id -> AttackPath
        
        # Correlation rules
        self.correlation_rules = self._load_correlation_rules()
        
        logger.info("Vulnerability Correlator initialized")

    def _load_correlation_rules(self) -> Dict[str, Any]:
        """Load vulnerability correlation rules"""
        return {
            # Information disclosure leading to other attacks
            'info_disclosure_chains': {
                'subdomain_takeover': {
                    'trigger': ['subdomain_enumeration', 'dns_misconfiguration'],
                    'enables': ['phishing', 'credential_harvesting', 'reputation_damage'],
                    'risk_multiplier': 2.0
                },
                'credential_exposure': {
                    'trigger': ['config_file_exposure', 'backup_file_access'],
                    'enables': ['authentication_bypass', 'privilege_escalation'],
                    'risk_multiplier': 3.0
                },
                'api_key_disclosure': {
                    'trigger': ['source_code_exposure', 'environment_file_access'],
                    'enables': ['api_abuse', 'data_access', 'service_impersonation'],
                    'risk_multiplier': 2.5
                }
            },
            
            # Injection vulnerabilities and their escalation paths
            'injection_chains': {
                'sqli_to_rce': {
                    'trigger': ['sql_injection', 'file_write_permissions'],
                    'enables': ['remote_code_execution', 'system_compromise'],
                    'risk_multiplier': 4.0
                },
                'xss_to_account_takeover': {
                    'trigger': ['stored_xss', 'session_management_weakness'],
                    'enables': ['session_hijacking', 'account_takeover'],
                    'risk_multiplier': 3.0
                },
                'ssti_to_rce': {
                    'trigger': ['server_side_template_injection'],
                    'enables': ['remote_code_execution', 'file_system_access'],
                    'risk_multiplier': 4.5
                }
            },
            
            # Authentication and authorization bypass chains
            'auth_bypass_chains': {
                'weak_auth_to_admin': {
                    'trigger': ['weak_authentication', 'admin_panel_access'],
                    'enables': ['administrative_access', 'system_control'],
                    'risk_multiplier': 3.5
                },
                'idor_to_data_breach': {
                    'trigger': ['insecure_direct_object_reference', 'sensitive_data_access'],
                    'enables': ['data_breach', 'privacy_violation'],
                    'risk_multiplier': 3.0
                }
            },
            
            # Business logic vulnerability chains
            'business_logic_chains': {
                'price_manipulation_to_fraud': {
                    'trigger': ['price_manipulation', 'payment_bypass'],
                    'enables': ['financial_fraud', 'revenue_loss'],
                    'risk_multiplier': 4.0
                },
                'race_condition_to_privilege_escalation': {
                    'trigger': ['race_condition', 'state_management_flaw'],
                    'enables': ['privilege_escalation', 'unauthorized_access'],
                    'risk_multiplier': 3.0
                }
            },
            
            # Configuration and infrastructure chains
            'config_chains': {
                'debug_mode_to_info_disclosure': {
                    'trigger': ['debug_mode_enabled', 'error_information_disclosure'],
                    'enables': ['source_code_disclosure', 'system_information_leak'],
                    'risk_multiplier': 2.0
                },
                'default_credentials_to_compromise': {
                    'trigger': ['default_credentials', 'administrative_interface'],
                    'enables': ['system_compromise', 'full_control'],
                    'risk_multiplier': 4.5
                }
            }
        }

    async def analyze_and_correlate(self, 
                                  reconnaissance_data: Dict[str, Any],
                                  vulnerability_data: Dict[str, Any],
                                  fuzzing_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability correlation analysis
        
        Args:
            reconnaissance_data: Results from reconnaissance phase
            vulnerability_data: Results from vulnerability scanning
            fuzzing_data: Results from fuzzing and exploitation
        """
        logger.info("Starting comprehensive vulnerability correlation analysis")
        
        correlation_results = {
            'knowledge_graph': {},
            'vulnerability_chains': [],
            'attack_paths': [],
            'risk_amplification': {},
            'critical_findings': [],
            'ai_analysis': {},
            'recommendations': []
        }
        
        # Phase 1: Build knowledge graph
        logger.info("Phase 1: Building knowledge graph")
        await self._build_knowledge_graph(reconnaissance_data, vulnerability_data, fuzzing_data)
        correlation_results['knowledge_graph'] = self._export_knowledge_graph()
        
        # Phase 2: Discover vulnerability chains
        logger.info("Phase 2: Discovering vulnerability chains")
        correlation_results['vulnerability_chains'] = await self._discover_vulnerability_chains()
        
        # Phase 3: Analyze attack paths
        logger.info("Phase 3: Analyzing attack paths")
        correlation_results['attack_paths'] = await self._analyze_attack_paths()
        
        # Phase 4: Calculate risk amplification
        logger.info("Phase 4: Calculating risk amplification")
        correlation_results['risk_amplification'] = await self._calculate_risk_amplification()
        
        # Phase 5: Identify critical findings
        logger.info("Phase 5: Identifying critical findings")
        correlation_results['critical_findings'] = await self._identify_critical_findings()
        
        # Phase 6: AI-powered correlation analysis
        if self.llm_client:
            logger.info("Phase 6: AI-powered correlation analysis")
            correlation_results['ai_analysis'] = await self._ai_correlation_analysis(correlation_results)
        
        # Phase 7: Generate actionable recommendations
        logger.info("Phase 7: Generating recommendations")
        correlation_results['recommendations'] = await self._generate_recommendations(correlation_results)
        
        logger.info(f"Correlation analysis completed. Found {len(correlation_results['vulnerability_chains'])} chains")
        return correlation_results

    async def _build_knowledge_graph(self, 
                                   recon_data: Dict[str, Any],
                                   vuln_data: Dict[str, Any],
                                   fuzz_data: Dict[str, Any]):
        """Build knowledge graph from all collected data"""
        
        # Add assets from reconnaissance data
        await self._add_assets_from_recon(recon_data)
        
        # Add vulnerabilities from all sources
        await self._add_vulnerabilities_from_data(vuln_data, fuzz_data)
        
        # Create relationships between assets and vulnerabilities
        await self._create_asset_vulnerability_relationships()
        
        # Add technology and service relationships
        await self._add_technology_relationships()

    async def _add_assets_from_recon(self, recon_data: Dict[str, Any]):
        """Extract and add assets from reconnaissance data"""
        
        # Add live hosts
        live_hosts = recon_data.get('asset_validation', {}).get('live_hosts', [])
        for host_info in live_hosts:
            if isinstance(host_info, dict):
                asset_id = f"host_{host_info.get('host', 'unknown')}"
                asset = Asset(
                    id=asset_id,
                    type='host',
                    value=host_info.get('host', ''),
                    properties=host_info,
                    technologies=[],
                    services=[]
                )
                self.assets[asset_id] = asset
                self.knowledge_graph.add_node(asset_id, type='asset', data=asset)
        
        # Add discovered APIs
        apis = recon_data.get('api_discovery', {}).get('discovered_apis', [])
        for api_info in apis:
            if isinstance(api_info, dict):
                asset_id = f"api_{api_info.get('url', 'unknown').replace('/', '_')}"
                asset = Asset(
                    id=asset_id,
                    type='api',
                    value=api_info.get('url', ''),
                    properties=api_info,
                    technologies=[api_info.get('api_type', 'unknown')],
                    services=[]
                )
                self.assets[asset_id] = asset
                self.knowledge_graph.add_node(asset_id, type='asset', data=asset)
        
        # Add technology fingerprints
        tech_data = recon_data.get('technology_fingerprinting', {})
        for url, tech_info in tech_data.items():
            asset_id = f"web_{url.replace('/', '_').replace(':', '_')}"
            if asset_id not in self.assets:
                asset = Asset(
                    id=asset_id,
                    type='web_service',
                    value=url,
                    properties=tech_info,
                    technologies=tech_info.get('technologies', []),
                    services=[]
                )
                self.assets[asset_id] = asset
                self.knowledge_graph.add_node(asset_id, type='asset', data=asset)

    async def _add_vulnerabilities_from_data(self, vuln_data: Dict[str, Any], fuzz_data: Dict[str, Any]):
        """Extract and add vulnerabilities from scanning and fuzzing data"""
        
        # Add vulnerabilities from vulnerability scanning
        for scan_type, scan_results in vuln_data.items():
            if isinstance(scan_results, dict):
                await self._extract_vulnerabilities_from_scan(scan_type, scan_results)
        
        # Add vulnerabilities from fuzzing data
        for fuzz_type, fuzz_results in fuzz_data.items():
            if isinstance(fuzz_results, dict):
                await self._extract_vulnerabilities_from_fuzz(fuzz_type, fuzz_results)

    async def _extract_vulnerabilities_from_scan(self, scan_type: str, scan_results: Dict[str, Any]):
        """Extract vulnerabilities from scan results"""
        
        # Handle different scan result formats
        if 'vulnerabilities_found' in scan_results:
            vulns = scan_results['vulnerabilities_found']
        elif 'issues' in scan_results:
            vulns = scan_results['issues']
        elif 'findings' in scan_results:
            vulns = scan_results['findings']
        else:
            # Try to find vulnerability-like data
            vulns = []
            for key, value in scan_results.items():
                if isinstance(value, list) and key in ['vulnerabilities', 'security_issues', 'findings']:
                    vulns = value
                    break
        
        for vuln_data in vulns:
            if isinstance(vuln_data, dict):
                vuln_id = f"vuln_{scan_type}_{len(self.vulnerabilities)}"
                
                # Determine vulnerability type
                vuln_type = self._classify_vulnerability_type(vuln_data)
                
                # Determine risk level
                risk_level = self._assess_risk_level(vuln_data)
                
                # Create vulnerability object
                vulnerability = Vulnerability(
                    id=vuln_id,
                    type=vuln_type,
                    asset_id=self._find_related_asset(vuln_data),
                    title=vuln_data.get('title', vuln_data.get('vulnerability', 'Unknown Vulnerability')),
                    description=vuln_data.get('description', vuln_data.get('details', '')),
                    risk_level=risk_level,
                    cvss_score=self._calculate_cvss_score(vuln_data, risk_level),
                    evidence=vuln_data,
                    exploitation_complexity=vuln_data.get('complexity', 'medium'),
                    prerequisites=vuln_data.get('prerequisites', []),
                    impact=vuln_data.get('impact', {})
                )
                
                self.vulnerabilities[vuln_id] = vulnerability
                self.knowledge_graph.add_node(vuln_id, type='vulnerability', data=vulnerability)

    async def _extract_vulnerabilities_from_fuzz(self, fuzz_type: str, fuzz_results: Dict[str, Any]):
        """Extract vulnerabilities from fuzzing results"""
        
        # Handle fuzzing-specific result formats
        if 'vulnerabilities_found' in fuzz_results:
            vulns = fuzz_results['vulnerabilities_found']
        elif 'interesting_responses' in fuzz_results:
            vulns = fuzz_results['interesting_responses']
        else:
            vulns = []
        
        for vuln_data in vulns:
            if isinstance(vuln_data, dict) and vuln_data.get('vulnerable', False):
                vuln_id = f"fuzz_{fuzz_type}_{len(self.vulnerabilities)}"
                
                # Classify fuzzing vulnerability
                vuln_type = self._classify_fuzzing_vulnerability(vuln_data)
                risk_level = self._assess_fuzzing_risk(vuln_data)
                
                vulnerability = Vulnerability(
                    id=vuln_id,
                    type=vuln_type,
                    asset_id=self._find_related_asset(vuln_data),
                    title=vuln_data.get('vulnerability', f'Fuzzing Finding: {fuzz_type}'),
                    description=vuln_data.get('description', f'Vulnerability found during {fuzz_type}'),
                    risk_level=risk_level,
                    cvss_score=self._calculate_cvss_score(vuln_data, risk_level),
                    evidence=vuln_data,
                    exploitation_complexity='medium',
                    prerequisites=[],
                    impact={'confidentiality': 'medium', 'integrity': 'medium', 'availability': 'low'}
                )
                
                self.vulnerabilities[vuln_id] = vulnerability
                self.knowledge_graph.add_node(vuln_id, type='vulnerability', data=vulnerability)

    def _classify_vulnerability_type(self, vuln_data: Dict[str, Any]) -> VulnerabilityType:
        """Classify vulnerability type based on data"""
        vuln_text = str(vuln_data).lower()
        
        if any(keyword in vuln_text for keyword in ['sql', 'injection', 'sqli']):
            return VulnerabilityType.INJECTION
        elif any(keyword in vuln_text for keyword in ['xss', 'script', 'cross-site']):
            return VulnerabilityType.INJECTION
        elif any(keyword in vuln_text for keyword in ['auth', 'login', 'credential']):
            return VulnerabilityType.AUTHENTICATION_BYPASS
        elif any(keyword in vuln_text for keyword in ['access', 'privilege', 'authorization']):
            return VulnerabilityType.AUTHORIZATION_BYPASS
        elif any(keyword in vuln_text for keyword in ['upload', 'file']):
            return VulnerabilityType.FILE_UPLOAD
        elif any(keyword in vuln_text for keyword in ['config', 'debug', 'info']):
            return VulnerabilityType.CONFIGURATION_ERROR
        elif any(keyword in vuln_text for keyword in ['disclosure', 'leak', 'exposure']):
            return VulnerabilityType.INFORMATION_DISCLOSURE
        elif any(keyword in vuln_text for keyword in ['business', 'logic', 'workflow']):
            return VulnerabilityType.BUSINESS_LOGIC
        else:
            return VulnerabilityType.UNKNOWN

    def _classify_fuzzing_vulnerability(self, vuln_data: Dict[str, Any]) -> VulnerabilityType:
        """Classify vulnerability type from fuzzing data"""
        vuln_type = vuln_data.get('vulnerability_type', '').lower()
        payload_type = vuln_data.get('payload', {}).get('type', '').lower()
        
        if 'sqli' in vuln_type or 'sql' in payload_type:
            return VulnerabilityType.INJECTION
        elif 'xss' in vuln_type or 'xss' in payload_type:
            return VulnerabilityType.INJECTION
        elif 'lfi' in vuln_type or 'rfi' in vuln_type:
            return VulnerabilityType.INJECTION
        elif 'idor' in vuln_type:
            return VulnerabilityType.AUTHORIZATION_BYPASS
        elif 'ssti' in vuln_type:
            return VulnerabilityType.INJECTION
        else:
            return VulnerabilityType.UNKNOWN

    def _assess_risk_level(self, vuln_data: Dict[str, Any]) -> RiskLevel:
        """Assess risk level of vulnerability"""
        risk_indicators = str(vuln_data).lower()
        
        if any(keyword in risk_indicators for keyword in ['critical', 'rce', 'remote code', 'system compromise']):
            return RiskLevel.CRITICAL
        elif any(keyword in risk_indicators for keyword in ['high', 'admin', 'privilege', 'authentication bypass']):
            return RiskLevel.HIGH
        elif any(keyword in risk_indicators for keyword in ['medium', 'injection', 'xss', 'disclosure']):
            return RiskLevel.MEDIUM
        elif any(keyword in risk_indicators for keyword in ['low', 'info', 'configuration']):
            return RiskLevel.LOW
        else:
            return RiskLevel.MEDIUM

    def _assess_fuzzing_risk(self, vuln_data: Dict[str, Any]) -> RiskLevel:
        """Assess risk level for fuzzing findings"""
        risk_level = vuln_data.get('risk_level', 'medium').lower()
        
        risk_mapping = {
            'critical': RiskLevel.CRITICAL,
            'high': RiskLevel.HIGH,
            'medium': RiskLevel.MEDIUM,
            'low': RiskLevel.LOW,
            'info': RiskLevel.INFO
        }
        
        return risk_mapping.get(risk_level, RiskLevel.MEDIUM)

    def _calculate_cvss_score(self, vuln_data: Dict[str, Any], risk_level: RiskLevel) -> float:
        """Calculate CVSS score based on vulnerability data and risk level"""
        # Simplified CVSS calculation
        base_scores = {
            RiskLevel.CRITICAL: 9.0,
            RiskLevel.HIGH: 7.5,
            RiskLevel.MEDIUM: 5.5,
            RiskLevel.LOW: 3.0,
            RiskLevel.INFO: 0.0
        }
        
        base_score = base_scores.get(risk_level, 5.5)
        
        # Adjust based on exploitation complexity
        complexity = vuln_data.get('exploitation_complexity', 'medium').lower()
        if complexity == 'low':
            base_score += 0.5
        elif complexity == 'high':
            base_score -= 0.5
        
        return min(10.0, max(0.0, base_score))

    def _find_related_asset(self, vuln_data: Dict[str, Any]) -> str:
        """Find the asset related to a vulnerability"""
        # Try to extract asset information from vulnerability data
        url = vuln_data.get('url', vuln_data.get('endpoint', ''))
        host = vuln_data.get('host', vuln_data.get('target', ''))
        
        if url:
            asset_id = f"web_{url.replace('/', '_').replace(':', '_')}"
            if asset_id in self.assets:
                return asset_id
        
        if host:
            asset_id = f"host_{host}"
            if asset_id in self.assets:
                return asset_id
        
        # Return first available asset if no specific match
        if self.assets:
            return list(self.assets.keys())[0]
        
        return 'unknown_asset'

    async def _create_asset_vulnerability_relationships(self):
        """Create relationships between assets and vulnerabilities in the graph"""
        for vuln_id, vulnerability in self.vulnerabilities.items():
            asset_id = vulnerability.asset_id
            
            if asset_id in self.assets:
                # Add edge from asset to vulnerability
                self.knowledge_graph.add_edge(asset_id, vuln_id, relationship='has_vulnerability')
                
                # Add reverse edge for easier traversal
                self.knowledge_graph.add_edge(vuln_id, asset_id, relationship='affects_asset')

    async def _add_technology_relationships(self):
        """Add technology and service relationships to the graph"""
        for asset_id, asset in self.assets.items():
            # Add technology nodes and relationships
            for tech in asset.technologies:
                tech_id = f"tech_{tech.replace(' ', '_').replace('.', '_')}"
                
                if not self.knowledge_graph.has_node(tech_id):
                    self.knowledge_graph.add_node(tech_id, type='technology', name=tech)
                
                self.knowledge_graph.add_edge(asset_id, tech_id, relationship='uses_technology')
            
            # Add service nodes and relationships
            for service in asset.services:
                service_name = service.get('name', service.get('service', 'unknown'))
                service_id = f"service_{service_name}_{service.get('port', 'unknown')}"
                
                if not self.knowledge_graph.has_node(service_id):
                    self.knowledge_graph.add_node(service_id, type='service', data=service)
                
                self.knowledge_graph.add_edge(asset_id, service_id, relationship='runs_service')

    async def _discover_vulnerability_chains(self) -> List[Dict[str, Any]]:
        """Discover vulnerability chains using correlation rules"""
        chains = []
        
        for chain_category, category_rules in self.correlation_rules.items():
            for chain_name, chain_rule in category_rules.items():
                # Find vulnerabilities that match the trigger conditions
                trigger_vulns = self._find_vulnerabilities_by_criteria(chain_rule['trigger'])
                
                if trigger_vulns:
                    # Check if this chain enables other vulnerabilities
                    enabled_vulns = self._find_vulnerabilities_by_criteria(chain_rule['enables'])
                    
                    if enabled_vulns:
                        chain = {
                            'id': f"chain_{chain_category}_{chain_name}",
                            'name': chain_name,
                            'category': chain_category,
                            'trigger_vulnerabilities': trigger_vulns,
                            'enabled_vulnerabilities': enabled_vulns,
                            'risk_multiplier': chain_rule['risk_multiplier'],
                            'description': self._generate_chain_description(chain_name, trigger_vulns, enabled_vulns),
                            'total_risk_score': self._calculate_chain_risk_score(trigger_vulns, enabled_vulns, chain_rule['risk_multiplier'])
                        }
                        chains.append(chain)
        
        # Sort chains by risk score
        chains.sort(key=lambda x: x['total_risk_score'], reverse=True)
        
        return chains

    def _find_vulnerabilities_by_criteria(self, criteria: List[str]) -> List[str]:
        """Find vulnerabilities that match given criteria"""
        matching_vulns = []
        
        for vuln_id, vulnerability in self.vulnerabilities.items():
            vuln_text = f"{vulnerability.title} {vulnerability.description}".lower()
            
            # Check if any criteria keyword matches
            for criterion in criteria:
                criterion_words = criterion.replace('_', ' ').split()
                if all(word in vuln_text for word in criterion_words):
                    matching_vulns.append(vuln_id)
                    break
        
        return matching_vulns

    def _generate_chain_description(self, chain_name: str, trigger_vulns: List[str], enabled_vulns: List[str]) -> str:
        """Generate human-readable description for vulnerability chain"""
        trigger_titles = [self.vulnerabilities[vid].title for vid in trigger_vulns[:3]]
        enabled_titles = [self.vulnerabilities[vid].title for vid in enabled_vulns[:3]]
        
        description = f"Chain '{chain_name}' triggered by: {', '.join(trigger_titles)}"
        if len(trigger_vulns) > 3:
            description += f" and {len(trigger_vulns) - 3} more"
        
        description += f". This enables: {', '.join(enabled_titles)}"
        if len(enabled_vulns) > 3:
            description += f" and {len(enabled_vulns) - 3} more"
        
        return description

    def _calculate_chain_risk_score(self, trigger_vulns: List[str], enabled_vulns: List[str], multiplier: float) -> float:
        """Calculate total risk score for a vulnerability chain"""
        trigger_scores = [self.vulnerabilities[vid].cvss_score for vid in trigger_vulns]
        enabled_scores = [self.vulnerabilities[vid].cvss_score for vid in enabled_vulns]
        
        base_score = sum(trigger_scores) + sum(enabled_scores)
        return base_score * multiplier

    async def _analyze_attack_paths(self) -> List[AttackPath]:
        """Analyze possible attack paths through the knowledge graph"""
        attack_paths = []
        
        # Find all paths from low-privilege vulnerabilities to high-impact ones
        low_risk_vulns = [vid for vid, vuln in self.vulnerabilities.items() 
                         if vuln.risk_level in [RiskLevel.LOW, RiskLevel.INFO]]
        
        high_risk_vulns = [vid for vid, vuln in self.vulnerabilities.items() 
                          if vuln.risk_level in [RiskLevel.CRITICAL, RiskLevel.HIGH]]
        
        for start_vuln in low_risk_vulns:
            for end_vuln in high_risk_vulns:
                # Find paths through the knowledge graph
                try:
                    if nx.has_path(self.knowledge_graph, start_vuln, end_vuln):
                        paths = list(nx.all_simple_paths(self.knowledge_graph, start_vuln, end_vuln, cutoff=5))
                        
                        for path in paths[:3]:  # Limit to 3 paths per pair
                            # Filter path to only include vulnerabilities
                            vuln_path = [node for node in path if node.startswith('vuln_') or node.startswith('fuzz_')]
                            
                            if len(vuln_path) >= 2:
                                attack_path = AttackPath(
                                    id=f"path_{len(attack_paths)}",
                                    vulnerabilities=vuln_path,
                                    description=self._generate_path_description(vuln_path),
                                    total_risk_score=self._calculate_path_risk_score(vuln_path),
                                    feasibility=self._assess_path_feasibility(vuln_path),
                                    business_impact=self._assess_business_impact(vuln_path),
                                    steps=self._generate_path_steps(vuln_path)
                                )
                                attack_paths.append(attack_path)
                                
                except nx.NetworkXNoPath:
                    continue
        
        # Sort by risk score
        attack_paths.sort(key=lambda x: x.total_risk_score, reverse=True)
        
        return attack_paths[:20]  # Return top 20 attack paths

    def _generate_path_description(self, vuln_path: List[str]) -> str:
        """Generate description for an attack path"""
        if len(vuln_path) < 2:
            return "Single vulnerability"
        
        start_vuln = self.vulnerabilities[vuln_path[0]]
        end_vuln = self.vulnerabilities[vuln_path[-1]]
        
        return f"Attack path from '{start_vuln.title}' to '{end_vuln.title}' through {len(vuln_path) - 2} intermediate steps"

    def _calculate_path_risk_score(self, vuln_path: List[str]) -> float:
        """Calculate risk score for an attack path"""
        scores = [self.vulnerabilities[vid].cvss_score for vid in vuln_path]
        
        # Weight later vulnerabilities higher (escalation effect)
        weighted_score = sum(score * (i + 1) for i, score in enumerate(scores))
        
        return weighted_score / len(vuln_path)

    def _assess_path_feasibility(self, vuln_path: List[str]) -> str:
        """Assess feasibility of an attack path"""
        complexities = [self.vulnerabilities[vid].exploitation_complexity for vid in vuln_path]
        
        if all(c == 'low' for c in complexities):
            return 'high'
        elif any(c == 'high' for c in complexities):
            return 'low'
        else:
            return 'medium'

    def _assess_business_impact(self, vuln_path: List[str]) -> str:
        """Assess business impact of an attack path"""
        risk_levels = [self.vulnerabilities[vid].risk_level for vid in vuln_path]
        
        if RiskLevel.CRITICAL in risk_levels:
            return 'critical'
        elif RiskLevel.HIGH in risk_levels:
            return 'high'
        else:
            return 'medium'

    def _generate_path_steps(self, vuln_path: List[str]) -> List[Dict[str, Any]]:
        """Generate step-by-step attack path"""
        steps = []
        
        for i, vuln_id in enumerate(vuln_path):
            vulnerability = self.vulnerabilities[vuln_id]
            
            step = {
                'step_number': i + 1,
                'vulnerability_id': vuln_id,
                'title': vulnerability.title,
                'description': vulnerability.description,
                'risk_level': vulnerability.risk_level.value,
                'exploitation_method': self._suggest_exploitation_method(vulnerability),
                'expected_outcome': self._predict_exploitation_outcome(vulnerability)
            }
            steps.append(step)
        
        return steps

    def _suggest_exploitation_method(self, vulnerability: Vulnerability) -> str:
        """Suggest exploitation method for a vulnerability"""
        vuln_type = vulnerability.type
        
        methods = {
            VulnerabilityType.INJECTION: "Craft malicious payloads to exploit injection points",
            VulnerabilityType.AUTHENTICATION_BYPASS: "Use credential stuffing or bypass techniques",
            VulnerabilityType.AUTHORIZATION_BYPASS: "Manipulate requests to access unauthorized resources",
            VulnerabilityType.FILE_UPLOAD: "Upload malicious files to gain code execution",
            VulnerabilityType.CONFIGURATION_ERROR: "Exploit misconfigurations to gain access",
            VulnerabilityType.INFORMATION_DISCLOSURE: "Extract sensitive information for further attacks",
            VulnerabilityType.BUSINESS_LOGIC: "Abuse application logic flaws",
            VulnerabilityType.UNKNOWN: "Manual analysis required"
        }
        
        return methods.get(vuln_type, "Manual exploitation required")

    def _predict_exploitation_outcome(self, vulnerability: Vulnerability) -> str:
        """Predict the outcome of exploiting a vulnerability"""
        vuln_type = vulnerability.type
        risk_level = vulnerability.risk_level
        
        if risk_level == RiskLevel.CRITICAL:
            return "Full system compromise possible"
        elif risk_level == RiskLevel.HIGH:
            if vuln_type == VulnerabilityType.INJECTION:
                return "Code execution or data extraction"
            elif vuln_type == VulnerabilityType.AUTHENTICATION_BYPASS:
                return "Administrative access gained"
            else:
                return "Significant security breach"
        elif risk_level == RiskLevel.MEDIUM:
            return "Partial access or information disclosure"
        else:
            return "Limited impact or information gathering"

    async def _calculate_risk_amplification(self) -> Dict[str, Any]:
        """Calculate how vulnerabilities amplify each other's risk"""
        amplification_results = {
            'amplified_vulnerabilities': [],
            'risk_multipliers': {},
            'combined_impact_scenarios': []
        }
        
        # Analyze vulnerability combinations
        vuln_list = list(self.vulnerabilities.values())
        
        for i, vuln1 in enumerate(vuln_list):
            for vuln2 in vuln_list[i+1:]:
                # Check if vulnerabilities are on the same asset
                if vuln1.asset_id == vuln2.asset_id:
                    amplification = self._calculate_vulnerability_amplification(vuln1, vuln2)
                    
                    if amplification['amplified']:
                        amplification_results['amplified_vulnerabilities'].append(amplification)
        
        # Calculate overall risk multipliers
        for asset_id in self.assets:
            asset_vulns = [v for v in self.vulnerabilities.values() if v.asset_id == asset_id]
            if len(asset_vulns) > 1:
                base_risk = sum(v.cvss_score for v in asset_vulns)
                amplified_risk = self._calculate_amplified_risk(asset_vulns)
                
                amplification_results['risk_multipliers'][asset_id] = {
                    'base_risk': base_risk,
                    'amplified_risk': amplified_risk,
                    'multiplier': amplified_risk / base_risk if base_risk > 0 else 1.0
                }
        
        return amplification_results

    def _calculate_vulnerability_amplification(self, vuln1: Vulnerability, vuln2: Vulnerability) -> Dict[str, Any]:
        """Calculate amplification between two vulnerabilities"""
        amplification = {
            'vulnerability_1': vuln1.id,
            'vulnerability_2': vuln2.id,
            'amplified': False,
            'amplification_factor': 1.0,
            'reason': ''
        }
        
        # Check for specific amplification patterns
        if (vuln1.type == VulnerabilityType.INFORMATION_DISCLOSURE and 
            vuln2.type == VulnerabilityType.INJECTION):
            amplification['amplified'] = True
            amplification['amplification_factor'] = 2.5
            amplification['reason'] = 'Information disclosure enables targeted injection attacks'
        
        elif (vuln1.type == VulnerabilityType.AUTHENTICATION_BYPASS and 
              vuln2.type == VulnerabilityType.AUTHORIZATION_BYPASS):
            amplification['amplified'] = True
            amplification['amplification_factor'] = 3.0
            amplification['reason'] = 'Authentication bypass combined with authorization bypass enables full access'
        
        elif (vuln1.type == VulnerabilityType.FILE_UPLOAD and 
              vuln2.type == VulnerabilityType.INJECTION):
            amplification['amplified'] = True
            amplification['amplification_factor'] = 4.0
            amplification['reason'] = 'File upload combined with injection can lead to remote code execution'
        
        return amplification

    def _calculate_amplified_risk(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate amplified risk for multiple vulnerabilities on the same asset"""
        if len(vulnerabilities) <= 1:
            return sum(v.cvss_score for v in vulnerabilities)
        
        base_score = sum(v.cvss_score for v in vulnerabilities)
        
        # Apply amplification based on vulnerability types
        type_combinations = [v.type for v in vulnerabilities]
        
        # High amplification combinations
        if (VulnerabilityType.INFORMATION_DISCLOSURE in type_combinations and 
            VulnerabilityType.INJECTION in type_combinations):
            return base_score * 1.5
        
        if (VulnerabilityType.AUTHENTICATION_BYPASS in type_combinations and 
            VulnerabilityType.AUTHORIZATION_BYPASS in type_combinations):
            return base_score * 1.8
        
        # Medium amplification for multiple vulnerabilities
        return base_score * (1 + 0.1 * (len(vulnerabilities) - 1))

    async def _identify_critical_findings(self) -> List[Dict[str, Any]]:
        """Identify the most critical findings requiring immediate attention"""
        critical_findings = []
        
        # Critical individual vulnerabilities
        for vuln_id, vulnerability in self.vulnerabilities.items():
            if vulnerability.risk_level == RiskLevel.CRITICAL:
                critical_findings.append({
                    'type': 'critical_vulnerability',
                    'id': vuln_id,
                    'title': vulnerability.title,
                    'description': vulnerability.description,
                    'risk_score': vulnerability.cvss_score,
                    'asset': vulnerability.asset_id,
                    'priority': 'immediate'
                })
        
        # High-risk vulnerability chains
        chains = await self._discover_vulnerability_chains()
        for chain in chains[:5]:  # Top 5 chains
            if chain['total_risk_score'] > 15.0:
                critical_findings.append({
                    'type': 'vulnerability_chain',
                    'id': chain['id'],
                    'title': f"High-Risk Chain: {chain['name']}",
                    'description': chain['description'],
                    'risk_score': chain['total_risk_score'],
                    'vulnerabilities': chain['trigger_vulnerabilities'] + chain['enabled_vulnerabilities'],
                    'priority': 'high'
                })
        
        # High-impact attack paths
        attack_paths = await self._analyze_attack_paths()
        for path in attack_paths[:3]:  # Top 3 paths
            if path.total_risk_score > 8.0:
                critical_findings.append({
                    'type': 'attack_path',
                    'id': path.id,
                    'title': f"Critical Attack Path",
                    'description': path.description,
                    'risk_score': path.total_risk_score,
                    'vulnerabilities': path.vulnerabilities,
                    'priority': 'high'
                })
        
        # Sort by risk score
        critical_findings.sort(key=lambda x: x['risk_score'], reverse=True)
        
        return critical_findings

    async def _ai_correlation_analysis(self, correlation_results: Dict[str, Any]) -> Dict[str, Any]:
        """Use AI to perform advanced correlation analysis"""
        if not self.llm_client:
            return {'error': 'No LLM client available'}
        
        # Prepare context for AI analysis
        context = {
            'total_assets': len(self.assets),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerability_chains': len(correlation_results['vulnerability_chains']),
            'attack_paths': len(correlation_results['attack_paths']),
            'critical_findings': len(correlation_results['critical_findings'])
        }
        
        # Create summary of findings for AI
        findings_summary = self._create_findings_summary(correlation_results)
        
        prompt = f"""
        Analyze the following vulnerability correlation results and provide strategic insights:

        Context:
        - Total Assets: {context['total_assets']}
        - Total Vulnerabilities: {context['total_vulnerabilities']}
        - Vulnerability Chains: {context['vulnerability_chains']}
        - Attack Paths: {context['attack_paths']}
        - Critical Findings: {context['critical_findings']}

        Findings Summary:
        {findings_summary}

        Please provide:
        1. Strategic risk assessment of the overall security posture
        2. Most concerning attack scenarios based on the correlation analysis
        3. Hidden risks that might not be obvious from individual vulnerabilities
        4. Prioritized remediation strategy
        5. Business impact assessment
        6. Advanced attack techniques that could exploit these vulnerability combinations

        Focus on actionable insights that go beyond individual vulnerability reports.
        """
        
        try:
            ai_response = await self.llm_client.agenerate(prompt)
            
            return {
                'ai_analysis': ai_response,
                'context_provided': context,
                'analysis_type': 'strategic_correlation_analysis'
            }
        except Exception as e:
            logger.error(f"AI correlation analysis error: {e}")
            return {'error': str(e)}

    def _create_findings_summary(self, correlation_results: Dict[str, Any]) -> str:
        """Create a concise summary of findings for AI analysis"""
        summary_parts = []
        
        # Vulnerability chains summary
        chains = correlation_results.get('vulnerability_chains', [])
        if chains:
            top_chain = chains[0]
            summary_parts.append(f"Top vulnerability chain: {top_chain['name']} (risk score: {top_chain['total_risk_score']:.1f})")
        
        # Attack paths summary
        paths = correlation_results.get('attack_paths', [])
        if paths:
            top_path = paths[0]
            summary_parts.append(f"Critical attack path: {top_path.description} (risk score: {top_path.total_risk_score:.1f})")
        
        # Critical findings summary
        critical = correlation_results.get('critical_findings', [])
        if critical:
            summary_parts.append(f"Critical findings: {len(critical)} high-priority issues identified")
        
        return '; '.join(summary_parts) if summary_parts else 'No significant correlations found'

    async def _generate_recommendations(self, correlation_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate actionable recommendations based on correlation analysis"""
        recommendations = []
        
        # Recommendations for vulnerability chains
        chains = correlation_results.get('vulnerability_chains', [])
        for chain in chains[:3]:  # Top 3 chains
            recommendations.append({
                'type': 'chain_mitigation',
                'priority': 'high',
                'title': f"Break vulnerability chain: {chain['name']}",
                'description': f"Address the trigger vulnerabilities to prevent chain exploitation",
                'actions': [
                    f"Fix trigger vulnerabilities: {', '.join(chain['trigger_vulnerabilities'][:3])}",
                    "Implement defense in depth to prevent chain exploitation",
                    "Monitor for indicators of chain exploitation attempts"
                ],
                'business_justification': f"Prevents escalation with risk multiplier of {chain['risk_multiplier']}x"
            })
        
        # Recommendations for attack paths
        paths = correlation_results.get('attack_paths', [])
        for path in paths[:2]:  # Top 2 paths
            recommendations.append({
                'type': 'path_blocking',
                'priority': 'high',
                'title': f"Block critical attack path",
                'description': path.description,
                'actions': [
                    "Implement access controls between attack path steps",
                    "Add monitoring for attack path indicators",
                    "Prioritize fixing the initial vulnerability in the path"
                ],
                'business_justification': f"Prevents {path.business_impact} impact scenarios"
            })
        
        # Recommendations for critical findings
        critical = correlation_results.get('critical_findings', [])
        for finding in critical[:5]:  # Top 5 critical findings
            recommendations.append({
                'type': 'critical_fix',
                'priority': 'immediate' if finding['priority'] == 'immediate' else 'high',
                'title': f"Address critical finding: {finding['title']}",
                'description': finding['description'],
                'actions': [
                    "Immediate remediation required",
                    "Implement temporary mitigations if fix requires time",
                    "Verify fix effectiveness through retesting"
                ],
                'business_justification': f"Addresses {finding['risk_score']:.1f} CVSS risk score"
            })
        
        # General recommendations based on correlation patterns
        if len(self.vulnerabilities) > 10:
            recommendations.append({
                'type': 'security_program',
                'priority': 'medium',
                'title': 'Implement comprehensive vulnerability management',
                'description': 'Large number of vulnerabilities indicates need for systematic approach',
                'actions': [
                    'Establish regular vulnerability scanning schedule',
                    'Implement vulnerability prioritization based on correlation analysis',
                    'Create incident response procedures for vulnerability chains'
                ],
                'business_justification': 'Reduces overall security risk and prevents future vulnerability accumulation'
            })
        
        return recommendations

    def _export_knowledge_graph(self) -> Dict[str, Any]:
        """Export knowledge graph for visualization and analysis"""
        return {
            'nodes': [
                {
                    'id': node,
                    'type': self.knowledge_graph.nodes[node].get('type', 'unknown'),
                    'data': str(self.knowledge_graph.nodes[node].get('data', {}))[:200]  # Truncate for export
                }
                for node in self.knowledge_graph.nodes()
            ],
            'edges': [
                {
                    'source': edge[0],
                    'target': edge[1],
                    'relationship': self.knowledge_graph.edges[edge].get('relationship', 'related')
                }
                for edge in self.knowledge_graph.edges()
            ],
            'statistics': {
                'total_nodes': self.knowledge_graph.number_of_nodes(),
                'total_edges': self.knowledge_graph.number_of_edges(),
                'assets': len([n for n in self.knowledge_graph.nodes() if self.knowledge_graph.nodes[n].get('type') == 'asset']),
                'vulnerabilities': len([n for n in self.knowledge_graph.nodes() if self.knowledge_graph.nodes[n].get('type') == 'vulnerability']),
                'technologies': len([n for n in self.knowledge_graph.nodes() if self.knowledge_graph.nodes[n].get('type') == 'technology'])
            }
        }